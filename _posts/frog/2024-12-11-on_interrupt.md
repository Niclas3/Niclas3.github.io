---
title: on_interrupt
updated: Wed Dec 11 12:15:59 CST 2024
categories : frog
---

# 聊聊中断

## 起因

我一直维护一个项目叫做`frog`，它是一个基于x86的32bits操作系统。最近想要 着手
给他增加网络功能，在增加之前首先需要替换或者更新之前孱弱的中断系统，之前由于
这个操作系统只需要使用三种外部中断，**时钟中断**，**键盘中断**和**鼠标中断**,秉着
够用就行的原则我使用的是古老的PIC+PIT，PIC提供中断控制，PIT提供时钟中断。现在需要
支持网卡需要支持的设备越来越多,也许增加一个设备总线(PCI)是更好的选择。

## 作为通知机制的中断
中断是硬件和CPU交互的机制之一，除了中断还有**轮询**,**DMA**,**I/O映射**,**消息专递(MSI)**。
中断是一种有效的通知机制，尤其是在需要快速响应的异步处理场景。中断可以直接打断CPU
处理的当前问题执行指定任务(这个在OS里也有类似的机制，**抢占式多任务**)
。中断也可以有优先级，通过一个PIC或者APIC，一种中断控制器来判断各种中断的优先级。

### Exception --- 同步中断(synchronous intrrupt)
同步中断是由CPU发起的，当指令发生异常的时候则会触发同步中断，比如缺页异常，除零异常
所以这个中断又被称之为异常(exception), x86-32 CPU提供一些默认的[exception](https://wiki.osdev.org/Exceptions)

### Interrupt --- 非同步中断(asynchronous intrrupt)
非同步中断是外部硬件在任意时间和CPU交互的手段，这也是本文着重的部分。

Intel 的文档是这样分类这两种中断的

* Interrupt 
  可屏蔽中断(Maskable interrupt)
    所有的I/O外设(外部硬件)发起的IRQs都是可屏蔽中断, 可屏蔽中断有**可以屏蔽**和**不可以
    屏蔽**两个状态。一般可执行中断都是会经过PIC(可编程中断控制器)传入CPU
    > 具体来说以x86-32架构就是EFLAG寄存器里的IF标识和PIC的IMR(interrupt must register)
    控制。这两个控制机制算是x86架构中的两级控制。
    IMR是PIC的一部分可以控制某些信号直接不传入CPU
    EFLAG的IF是CPU控制自己不去响应中断
    IMR配置和你的中断控制器有关，`frog`目前使用的是8259A 所以IMR master是
    0x21端口, IMR slave是0xA1端口。如果后续改成APIC就不需要IMR而是使用APIC提供的
    中断优先级和屏蔽机制管理IRQ。

    CPU部分的nasm语法就是`sti` 和`cli`。分别是设置屏蔽和清除屏蔽。

  不可屏蔽中断(Nonmaskable interrupt)
    只有一些比较重要的事件(比如硬件错误,内存控制器或者看门狗)会发起一些不可屏蔽中断,
    NMI信号会直接连接CPU，而不通过PIC。
    > 在intel文档vol-3 6.3.1节表格6-1展示了NMI interrupt的中断号是0x02
    
* Exceptions
    处理器监测到的异常(Processor-detected exceptions)
        这种异常是CPU在运行指令的时候监测到的异常。这种异常是同步触发，这种异常是由
        操作系统异常处理代码处理的，这种异常通常是程序错误引起的。
        这种异常大概可以以是不是会被保存现场信息比如把`eip`这个寄存器存入**内核栈**
        分为3类faults,traps and aborts。
        这里我想引入一个概念“指令完成”,指令完成指的是指令的所有步骤都执行完毕
        取指、解码、执行、写回。这个概念是CPU制造需要用到的具体可以用CPU流水线
        来详细了解。
        
        * 错误(Faults)
            错误(Faults)是在指令**尚未完成**时触发的异常
            这是一种可以被改正的异常，发现错误之后一旦被改正之后就可以恢复正常
            的**执行流**。当一个指令发生Faults类型的异常的时候会把**当前指令**的eip
            压栈保存起来，进入对应的异常处理程序，异常处理完成之后会从利用之前保存
            的eip中恢复原来的执行流，会从触发faults的指令开始执行。
            例如：页面错误(page fault)，段错误(segment fault)
        * 陷阱(Traps)
            陷阱(Traps)是在指令**已经完成**后触发的异常。
            这个陷阱和software Interrupt关系也不小，software Interrupt其实就是一个Traps类型的exception。
            Traps是一种不可以恢复的异常，一旦触发了traps那么**这条指令的下一条指令**的eip
            则会被押入栈中保存。异常处理结束后会接着下面的指令恢复原来的执行流。
            例如：x86-32 架构中有3个异常分别是#DB, #BP, #OF(debug exception,
            breakpoint, overflow)

            #DB (debug exception)
            这个既可以是faults也可以是traps，双重属性是为了提供断点，单步执行，
            数据观察。这个有很多功能之后写文章详细说明。

            #BP (breakpoint Exception)
            这个提供了断点为了设置断点。`int3`是x86专门设计的单字节中断指令(0xCC)

            #OF (Overflow Exception)
            这是为了检查算数操作的溢出(Signed Overflow)。`into`是为了直接出发这个Traps
            (这个很少用，算数溢出在应用层就会被捕获了很少到CPU还没处理的)

        * 终止(Aborts)
            这里只有发生非常严重的问题的同时还才会触发的一类异常。这时候有可能连
            eip或者栈都被破坏了。这是一种不可恢复的异常。
            intel 提供了两种

            #MC (Machine Check，机器检查)
                某种严重的硬件故障。比如内存ECC校验失败。缓存一致性错误，总线传输
                错误，等其他不可恢复的硬件错误。
                这个需要读取硬件提供的MCA(Machine check architecture)寄存器获取
                具体错误原因。

            #DF (Double fault，双重故障)
                当CPU处理异常的时候又发生了异常。
                这个时候可以记录上下文信息。
* Programmed exceptions
    这个和软件中断(software interrupt)差不多，它也是由程序的指令生成的不是硬件事件引发的。他们有俩个指令`bound`, `into`。
    `into`已经讲过了。
    `bound`是这样用的,他是为了检测数组或者数据范围是否超出指定边界
        
    第一个操作数是要检查的索引或者值
    第二个操作数是内存地址，包含两个边界值(低边界，高边界)
    如果寄存器的值小于低边界或者大于高边界，触发**#BR(bounds check exception)**
    
    ```
    bound reg, mem
    ```

intel 给了8bits 做中断向量表所以中断向量一共0-255个。

## 作为执行流的中断
**执行流**定义为一段正在执行的代码。要知道一段正在执行的代码需要一些必要的外围环境
作为支持，最重要的**外围环境**(context)就是**栈**和**cpu寄存器**来处理函数调用和一
些局部变量的存储。这次讨论着重考虑**栈**的作用，在一个OS主要有如下9种**执行流**,我
会分别给出他们使用的**栈**。

   类型                         栈类型
1. 普通进程(用户进程)           用户栈/内核栈
2. 内核进程                     内核栈

3. 中断处理程序(ISR)            内核栈/中断栈 \
4. 异常处理程序(exceptions)     内核栈        |  中断有关
5. 软中断(Softirqs&tasklets)    内核栈        |
6. 工作队列(work Queues)        内核栈        /

7. 信号处理程序   (*)           用户栈/信号栈
8. 异步I/O回调    (*)           用户栈/内核栈
9. 引导程序                     初始栈


## 中断的细节
### 简要中断处理流程
1. 硬件设备通过中断信号线向中断控制器发出IRQs(Interrupt ReQuests)
2. 中断控制器把中断号发送给CPU
3. CPU根据中断号查询中断向量表(IVT/IDT)执行对应的中断服务程序(ISR)
4. 中断处理完之后，CPU向中断控制器发送处理完毕的信号以便中断控制器可以接受别的信号

    中断的发生和处理涉及到硬件和软件两个系统，每一个系统都提供了相应的功能，上面
    指出的处理流程1.2.是关于硬件的部分，3.4.是关于软件的处理部分我会分别厘清这些
    顺序和具体做了什么事情。

### 硬件部分PIC(中断控制器)和各种会发出中断的硬件设备
        # 目前只考虑PIC的情况，如果之后Frog会支持APIC会补充APIC的新文章

    聊中断硬件部分的时候我们需要两个硬件。一个是发生硬件的设备,这次我选网卡。还有
    一个是PIC，PIC是用来管理不同中断和CPU通信的中介，主要负责
    1. 接受中断请求。2. 判断是否转发中断请求给CPU(屏蔽检查，优先级判断，服务中检查)
    3. 发送中断服务到CPU 4.接受EOI(End of Interrupt)信号。

    现在我们假设一个网卡接受到来自远方的数据包，他发出一个中断请求到PIC上，网卡和
    PIC是通过铜线相连。
    1.PIC接受中断信号。
        这时候PIC接受到网卡中断信号，中断请求记录在IRR(中断请求寄存器)中。
    2.PIC判断是否通知CPU
        这时候PIC需要判断这个网卡中断是不是可以转发给CPU了，
        * 他需要判断IMR(中断屏蔽寄存器)来检查这个中断有没有被PIC屏蔽，
        * 需要检查ISR(服务中寄存器)查看这个类型的中断是不是已经发送给CPU
        * 且CPU还没有返回EOI释放中断线，最后要判断现在这个中断的优先级，
          优先级高的中断是可以打断优先级低的中断的。
    3.PIC向CPU发送中断
        一系列判断过后，如果可以发送中断给CPU，那么PIC就会通过中断向量号告诉CPU中
        断类型(中断向量号是在PIC初始化的时候OS和PIC约定好的)。
    4.CPU 处理中断
        这里的操作我会在内核处理部分详细说明。之后CPU处理中断后会发送EOI信号给PIC
    5.PIC接受EOI信号
        PIC会接受到EOI信号清除ISR的标志位，释放中断线。
    6.PIC检查挂起的中断
        之后PIC会检查挂起的中断，也就是刚刚因为ISR存在而没有被响应的中断，PIC检查IRR如果又挂起的中断就会继续通知CPU。

    由刚刚的流程PIC在硬件层面已经做了一定程度的**优先级**和**同类型中断屏蔽**的功能。

    值得一提的是，就网卡中断来说，如果网卡中断被挂起数据包会缓存在网卡上的缓冲区中
    类似的硬件都有这种功能。

### 内核处理部分 
    CPU首先收到了来自PIC选择的中断,PIC传递来的是已经把IRQs线号转换后的中断向量号，
    (这是通过数据总线传输来的)intel的CPU有一个机制叫做中断门，CPU通过IDT(中断描述
    符表)CPU在得到这个中断向量后，使用中断向量号结合IDT查找到对应的中断处理程序的地址ISR(interrput
    service routine)。这时候就正式进入处理函数的部分，处理中断的流程以给PIC的端口
    发送EOI(end of interrupt)为分界分为2个部分。

    我们稍微把CPU时间往前拨动一点到，中断还没有从PIC发送到CPU时候。我们看看OS当时
    在做什么，这时候OS可能处于两种情况一种是工作在Ring3也就是用户态，一种是工作在
    Ring0也就是内核态，我挑选Ring3来解释。此时工作在用户态的操作系统由于中断的突然
    发生中断了当前的执行流，准备越过**中断门**进入IDT中记录的ISR的地址执行ISR。这时候
    由于CPU发现是Ring3->Ring0的权限提升所以需要借助TSS(Task State Segment)来切换
    当前使用的栈从ring3栈到ring0栈。CPU自动切换栈的同时，还把Ring3时的 
    `ss`, `esp`, `eflag` `cs`, `eip` 这5个寄存器的值依次压入了内核栈也就是ring0栈
    栈切换完毕，ring3的寄存器压入完毕之后，由于使用了中断门，所以`EFLAG`这个寄存器
    的`IF位`自动清零用来屏蔽可屏蔽中断，这些做完之后就正式进入目标中断向量号的ISR中开始处理中断

    ISR部分
    由于ISR会处理很多数据所以会尽可能的保存现场。Frog的处理方式是在每一次ISR的时
    候都会**依次**压入`ds``es` `fs` `gs` `pushad` `push %INR`(最后一个是压入中断
    向量号)到内核栈中。
    操作系统内核提供一个类似IDT一样的ISR的函数指针数组`intr_table`这里提供一些共用
    的代码(因为不同架构的CPU在中断处理上的汇编有所不同)。

    在准备好环境之后，ISR需要做的工作是移动一些数据到内存中,和挂起一个对应中断的
    softirq，一旦这数据处理完毕ISR的工作就结束了。
    这是就可以调用irq_exit() 结束ISR的部分。

    > `irq_exit()` 主要用处是给`PIC/APIC`发送**EOI**即调用`ack()`方法和查询有没有
    需要处理的softirqs如果有就启动对应类型的softirqs处理数据。等softirq结束之后
    结束整个中断运行流即调用iret
        
    Softirqs部分

    > 软中断(softirqs)和`int`指令触发的不同于硬件的软件中断(software interrupt)不同。

    首先softirqs是一种延迟处理中断的方式。我先聊一下没有softirq的时候中断如何处理
    我拿网络中断举例子，网络中断会根据刚刚我提到的一系列的从硬件到ISR，拿到网络包
    数据，之后直接使用网络协议栈处理这个包处理完成之后，结束这个中断的执行流。紧接
    着再来一个网络中断又是一样拿到数据->使用协议栈处理包。如果同时出现10个网络中断
    这样就会不停的被中断打断进行上下文切换，10次中断就需要打断10次并且每一次都需要
    使用网络协议栈处理数据包。如果有一种方式可以让10次中断变成只从网卡DMA拿数据到
    操作系统的FIFO缓存中，最后一次一次性处理FIFO缓存里所有的数据包。这样就节省了
    调用网络协议栈的时候的时间了。

    softirqs提供一个全局变量`pending`来记录不同类型的softirqs的[挂起]状态，一旦检测
    到有softirqs任务挂起，那么就会调用do_softirq来处理具体的任务，一般do_softirq()
    会处理所有正在挂起的softirq。由于softirq是可以被打断的，所以softirq的任务要适合
    打断可以重入。本质上说pending这个bitmap是在标记各个softirq对应的处理数据源buffer
    有无数据的展示，另一个角度来看其实是一种`生产-消费`的模型，硬件中断ISR部分是
    被控制不能打断的“生产者”，而softirqs部分是可以被打断的 “消费者“。生产者通过
    raise_softirqs()来挂起某个类型(预约)一个消费者来处理他产生的数据。
    
    
> 名词解释
[挂起(pending)] [一个任务暂时无法执行，因为他需要的一些条件还没有被满足。我可能会翻译为"代办"]

### 中断栈
    x64的设备会通过tss提供一个中断栈，Frog目前是32位系统所以等升级之后再考虑这些内容

### 中断优先级
### 中断嵌套
    中断嵌套存在两种不同定义的上下文。
    1. 
    中断嵌套的实现条件
        (1) 硬件支持
        PIC 或 APIC 必须支持中断优先级：
        如果中断 B 的优先级高于中断 A，PIC/APIC 会通知 CPU处理新的中断。
        低优先级的中断线（如 A）被屏蔽直到 B 处理完成。
        (2) 内核支持
        内核必须正确管理中断嵌套计数和上下文：
        进入新的中断时，内核会增加嵌套计数器。
        退出中断时，减少嵌套计数器，确保多层嵌套能够正确恢复。
        (3) 中断屏蔽机制
        通常，同一类型的中断（如同一个网卡的中断）会被内核配置为不可嵌套处理，以减少复杂性。
        但不同类型或更高优先级的中断可能会被允许打断。
        如果中断 B 到达而不能被响应，会发生什么？
        这取决于中断控制器和内核的配置。

    如果中断到达而不能被响应会发生什么
        (1) 中断被屏蔽（Masked）
        如果中断 B 被屏蔽（如同类型中断或低优先级中断），它将不会被响应。
        中断信号可能会保持挂起，直到屏蔽解除。例如：
        在 PIC 中，某条中断线被屏蔽时，即使有信号到达，PIC 不会通知 CPU。
        (2) 中断被丢弃
        某些硬件或驱动程序可能会忽略新的中断信号，而不会挂起等待。
        例如，在一些简单的设备中，如果缓冲区已满，新的中断可能被直接丢弃。
        (3) 中断队列（Interrupt Queuing）
        高级中断控制器（如 APIC 或现代 SoC 的中断控制器）可能会维护一个中断队列：
        当一个中断无法立即处理时，将其挂起。
        等待 CPU 处理完当前任务后再触发挂起的中断。
        (4) 中断 Storm 的风险
        如果新的中断持续到达而无法处理，可能导致所谓的 中断风暴（Interrupt Storm）。
        中断风暴会占用大量 CPU 时间，导致系统性能急剧下降

### 中断屏蔽

### 中断和信号(signal)
    这里可能会在讨论exception的文章里具体讨论中断和signal的关系

### 中断和tasklets
    tasklets是softirq的封装，目前Frog还不需要这样的封装，等需要的时候会更新的。

### 中断门
    中断门之后会在说保护模式的内容里详细提到。




