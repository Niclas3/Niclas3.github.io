---
layout: post
title: "[A]RTS   算法基础"
date: 2025-02-14
categories: []
tags: [ARTS]
---

## 计算机算法 VS 数学算法

首先我们需要分清楚什么是计算机算法什么是数学算法。简单来说数学算法是把数论的证明或者推论使用
程序的方式展现，比如说RAS加密算法。而计算机算法更像是一种“枚举”，比如说算出第k个素数是什么？

这两者有微妙的不同数学算法偏向于找到一个通用的解，计算机算法偏向于解决一个问题，是否通用或者
形式上合理不太重要。

如果你和我一样数学不好，只是希望使用算法找个工作。我们就一起看看计算机算法是如何“枚举”的。

## 枚举

枚举也可以叫穷举，就是一个一个数的意思。这件事看上去很简单，但其实要做到完美需要恰好数完所有情况
不能多不能少。“恰好”并不容易，我们可以从怎么枚举开始，到如何优化枚举。

大多数算法会围绕着这两件事情进行，有些问题容易写出枚举但是会超出时间或者空间，有些问题很难写出枚举手段找到枚举手段就是关键。

## 找到枚举
先说一下“递归问题”代表什么？

递归问题是一种存在重复且可以分解的子问题的一种问题，简单来说就是如果这个问题的解是一个函数那么这个函数
可以应用在这个问题的各个子问题上。

递归类问题可以来演示什么是“找到枚举”。

## 动态规划（Dynamic Programming）
一种典型的递归类问题。大部分使用动态规划的问题是求极值或者是计数。
如果一个问题的最优解可以由它的子问题的最优解构成。那么这个问题就具有“最优子结构”，这种性质是动态规划可以
通过递归来拆分问题的关键。

简单来看，动态规划通过一个可以递归的函数，把问题划分为多个子问题。我们就得到了子问题的集合，我们只需要遍历这些
子问题，就可以找到对应情况的值，从而发现“极值”或者给各个值计数。

总的来说可以使用动态规划的问题有4个要点：
1. 最优递归子结构 （最优子结构是可以使用DP的关键）
2. 重叠子问题     （重叠子问题会重复遍历同一个问题，这会拖慢效率，所以要避免）
3. 状态定义与转移方程 
4. 边界条件

## 斐波那契数列
我们来使用斐波那契数列来感受动态规划。
首先，斐波那契数列的递推公式是： F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1.

来分析一下斐波那契数列
1. 存在最优子结构。每一项都是前两项的和
2. 重叠子问题。    求第N项的时候可能重复计算前两项。

<pre class="mermaid" style="text-align: center;">
graph TD
    A["f(10)"] --> B["f(9)"]
    A --> C["f(8)"]
    B --> D["f(8)"]
    B --> E["f(7)"]
    C --> F["f(7)"]
    C --> G["f(6)"]

    class C,D blueNode;
    class E,F greenNode
    classDef blueNode fill:#aaaaff,stroke:#0000ff,stroke-width:2px;
    classDef greenNode fill:#aaccff,stroke:#00ffff,stroke-width:2px;
</pre>
算一下时间复杂度，也就是$\mathcal{O}()$,时间复杂度是单个子问题的处理时间乘以子问题个数。

* 算第3项子问题有两个需要计算f1和f2.
* 算第4项子问题有四个需要计算f3-f2和f2-f1
* 算第5项子问题有六个需要计算f4-f3和f3-f2和f2-f1
* 算第6项子问题有八个需要计算f5-f4和f4-f3和f3-f2和f2-f1
* 算第n项子问题有$\mathcal{O}(2^n)$ 

因为每个子问题都是加法所以单个子问题处理时间是$\mathcal{O}(1)$.

$\mathcal{O}(2^n) \times \mathcal{O}(1) = \mathcal{O}(2^n)$ 

计算某一个项的时间复杂度是指数级别，效率很差。原因是重复计算，类似图中其中第7和第8项都重复计算了
我也标记了相同的颜色。

## 自顶向下 - 备忘录

随之而来的就是引入备忘录（Memoization）来解决DP的特征之一**重叠子问题**。这也是**以时间换空间**的体现。

备忘录的引入逻辑很简单类似考试的小抄一样，它可以让你不必再计算一遍同样的答案只需要查找对应的题号就会得到对应的答案。
使用这种逻辑加速运算在历史上也比比皆是，1614年John Napier发明对数表；intel在CPU中使用TLB加速虚拟地址转换等等。

【这里补充一个C的带Memo的计算FP的代码】

这样一来使用了Memo的计算变少了
算一下时间复杂度

* 算第5项需要f4-f3和f3-f2和f2-f1,因为使用了memo所以只需要计算一次f1、f2、f3、f4、f5就可以了
* 算第N项也就是$\mathcal{O}(n)$

子问题的处理时间因为没有递归和循环所以也是$\mathcal{O}(1)$

$\mathcal{O}(n) \times \mathcal{O}(1) = \mathcal{O}(n)$ 

目前为值这就是DP的**自顶向下**的思路，也就是把大问题分解成小问题从大问题出发来分解规模的方式。

## 自底向上 - DP table

接下来我们来处理**自底向上**的思路，bottom-up的思路就是从基本情况向复杂情况推论的思路，使用
FP举例就是当F1=1,F2=1,那么按照公式F3=2。一步一步的填出一张表这个表一般叫他**DP
table**。
【这里补充一个Cbottom-up的FP代码】

这里会引入一个概念**状态转移方程**。这个词语相信有些人在FSM有限状态机里也听过，这两者虽然都描述着
从一个状态到另一个状态的转移，但DP是通过递归关系从子问题和之前状态推算出现在子问题的解。而FSM是通过
外部输入或者上一个状态，转移到另一个状态以用来做过程控制。

FP的状态转移方程我在上面给过了。
**状态转移**
把每一个项当作一个状态，这个状态是通过别的状态和输入参数组合来得出新状态。

仔细来看从base case出发一个一个填入数据这个过程和之前自上而下使用memo一样。只需要计算N个状态就好了。
所以bottom-up的思路的时间复杂度也是 $\mathcal{O}(n)$。

进一步你可以通过优化dptable的大小来优化这个算法

【C 优化 dp table大小的C代码】

我们首先想到的是一个长度为N的数组来充当dp
table，其实计算第k项只需要知道前两项的值就可以了 于是空间复杂度就可以从

--- 

由于FP没有极值的需求，所以没有最优子结构的问题。下面用[leetcode 322](https://leetcode.com/problems/coin-change/description/)来作为例子谈论
最优子结构。

## 零钱兑换

You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.
Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
You may assume that you have an infinite number of each kind of coin.


***最优子结构***，我们可以想像一下，最优子结构这个概念是什么？
首先是最优的，也就是这个概念在寻找一个极值。
其次是子结构，也就是这个结构是蕴含在每一次状态转换中的。

上文说到FP是没有最优子结构的，但是FP的确存在子结构，也就是Fn=Fn-1 + Fn-2；n glt
2。这个也是上文里提到的状态转移方程。大概可以如此断言，所有的DP问题是可以用状态转移方程来
描述子结构的。

## 找到更好的枚举


