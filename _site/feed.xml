<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>朝四暮三</title>
    <description>喜欢三是两听的金鱼杯</description>
    <link>http://localhost:4000</link>
    
      
        <item>
          <title>文件需要一个家</title>
          <description>&lt;p&gt;沿袭自UNIX的精神，”everything is a file.” 这里我们要讨论一下两件事，第一，
everything具体指的是什么东西？第二，file指的是什么?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;everything 泛指OS中的资源，也就是硬盘里的数据，进程，配置，内存数据，等等。&lt;/li&gt;
  &lt;li&gt;file 指的是一种结构，首先这种结构标记了一个范围的有意义的数据，且这个结构支持
 某种操作方式来处理这种结构。方式比如说，open/close/write/read/seek
 这一系列的操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;inode-x-vnode-x-file&quot;&gt;inode X vnode X file&lt;/h2&gt;
&lt;p&gt;inode: 提供一种文件和硬盘数据块的中间层抽象
vnode: 提供一种文件系统的节点
file : 提供一个运行时的文件抽象，为了和进程交互.&lt;/p&gt;

&lt;h2 id=&quot;文件系统&quot;&gt;文件系统&lt;/h2&gt;
&lt;p&gt;文件系统则是以文件这种结构组织数据的具体实现。&lt;/p&gt;
</description>
          <pubDate>2025-01-02T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/frog/2025/01/02/on_file_system.html</link>
          <guid isPermaLink="true">http://localhost:4000/frog/2025/01/02/on_file_system.html</guid>
        </item>
      
    
      
        <item>
          <title>聊聊中断</title>
          <description>&lt;h2 id=&quot;起因&quot;&gt;起因&lt;/h2&gt;

&lt;p&gt;我一直维护一个项目叫做&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frog&lt;/code&gt;，它是一个基于x86的32bits操作系统。最近想要 着手给他增加网络功能，在增加之前首先需要替换或者更新之前孱弱的中断系统，由于操作系统只需要使用三种外部中断，&lt;strong&gt;时钟中断&lt;/strong&gt;，&lt;strong&gt;键盘中断&lt;/strong&gt;和&lt;strong&gt;鼠标中断&lt;/strong&gt;,秉着够用就行的原则我使用的是古老的&lt;strong&gt;PIC&lt;/strong&gt;+&lt;strong&gt;PIT&lt;/strong&gt;，&lt;strong&gt;中断控制器(PIC)&lt;/strong&gt;提供中断控制，PIT提供时钟中断。现在需要支持网卡需要支持的设备越来越多,也许增加一个设备总线(PCI)是更好的选择。&lt;/p&gt;

&lt;p&gt;中断作为一种通知机制，是硬件与CPU高效通信的重要手段，尤其是处理异步时间时表现出色。&lt;/p&gt;

&lt;h2 id=&quot;作为通知机制的中断&quot;&gt;作为通知机制的中断&lt;/h2&gt;
&lt;p&gt;中断是硬件和CPU交互的机制之一，除了中断还有&lt;strong&gt;轮询&lt;/strong&gt;,&lt;strong&gt;DMA&lt;/strong&gt;,&lt;strong&gt;I/O映射&lt;/strong&gt;,&lt;strong&gt;消息专递(MSI)&lt;/strong&gt;。中断是一种有效的通知机制，尤其是在需要快速响应的异步处理场景。中断可以直接打断CPU处理的当前问题执行指定任务(这个在OS里也有类似的机制，&lt;strong&gt;抢占式多任务&lt;/strong&gt;)。中断也可以有优先级，通过一个PIC或者APIC，一种中断控制器来判断各种中断的优先级。&lt;/p&gt;

&lt;h3 id=&quot;exception--同步中断synchronous-interrupt&quot;&gt;Exception — 同步中断(synchronous interrupt)&lt;/h3&gt;
&lt;p&gt;同步中断是由CPU发起的，当指令发生异常的时候则会触发同步中断，比如&lt;strong&gt;缺页异常&lt;/strong&gt;，&lt;strong&gt;除零异常&lt;/strong&gt;所以这个中断又被称之为&lt;strong&gt;异常(exception)&lt;/strong&gt;, x86-32位，CPU提供一些默认的&lt;a href=&quot;https://wiki.osdev.org/Exceptions&quot;&gt;exception&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;interrupt--非同步中断asynchronous-interrupt&quot;&gt;Interrupt — 非同步中断(asynchronous interrupt)&lt;/h3&gt;
&lt;p&gt;非同步中断是外部硬件在任意时间和CPU交互的手段，这也是本文着重的部分。&lt;/p&gt;

&lt;p&gt;Intel 的文档是这样分类这两种中断的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Interrupt&lt;/strong&gt; 
&lt;strong&gt;可屏蔽中断(Maskable interrupt)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;所有的I/O外设(外部硬件)发起的IRQs都是&lt;strong&gt;可屏蔽中断&lt;/strong&gt;, 可屏蔽中断有&lt;strong&gt;可以屏蔽&lt;/strong&gt;和&lt;strong&gt;不可以屏蔽&lt;/strong&gt;两个状态。
  一般可执行中断都是会经过PIC(可编程中断控制器)传入CPU 。&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;具体来说以x86-32架构就是&lt;strong&gt;EFLAG&lt;/strong&gt;寄存器里的IF标识和PIC的&lt;strong&gt;IMR(interrupt must register)&lt;/strong&gt;控制。这两个控制机制算是x86架构中的两级控制。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;IMR（中断屏蔽寄存器）&lt;/strong&gt;属于PIC的一部分，负责屏蔽特定中断信号，不传入CPU。而&lt;strong&gt;EFLAG&lt;/strong&gt;寄存器中的&lt;strong&gt;IF&lt;/strong&gt;位，则用于CPU自身控制是否响应中断。&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;IMR&lt;/strong&gt;配置和你的中断控制器有关，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frog&lt;/code&gt;目前使用的是&lt;strong&gt;8259A&lt;/strong&gt; 所以&lt;strong&gt;IMR master&lt;/strong&gt;是
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x21&lt;/code&gt;端口, &lt;strong&gt;IMR slave&lt;/strong&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xA1&lt;/code&gt;端口。如果后续改成&lt;strong&gt;APIC&lt;/strong&gt;就不需要&lt;strong&gt;IMR&lt;/strong&gt;而是使用&lt;strong&gt;APIC&lt;/strong&gt;提供的
  中断优先级和屏蔽机制管理&lt;strong&gt;IRQ&lt;/strong&gt;。
  nasm语法就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sti&lt;/code&gt; 和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cli&lt;/code&gt;。分别是设置屏蔽和清除屏蔽。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;不可屏蔽中断(Nonmaskable interrupt)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;重要的事件(比如硬件错误,内存控制器或者看门狗)会发起一些&lt;strong&gt;不可屏蔽中断&lt;/strong&gt;,
NMI信号会&lt;strong&gt;直接连接CPU&lt;/strong&gt;，而不通过PIC。&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;在intel文档vol-3 6.3.1节表格6-1展示了NMI interrupt的中断号是0x02&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Exceptions&lt;/strong&gt;
  处理器监测到的异常(Processor-detected exceptions)&lt;/p&gt;

    &lt;p&gt;Exceptions是CPU在运行指令的时候监测到的异常。这种异常是同步触发，这种异常是由操作系统异常处理代码处理的，这种异常通常是程序错误引起的。这种异常大概可以以是不是会被保存现场信息比如把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eip&lt;/code&gt;这个寄存器存入&lt;strong&gt;内核栈&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Exceptions&lt;/strong&gt;分为3类&lt;strong&gt;faults&lt;/strong&gt;,&lt;strong&gt;traps&lt;/strong&gt; 和 &lt;strong&gt;aborts&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;在谈论Exception之前需要了解“&lt;strong&gt;指令完成&lt;/strong&gt;”。&lt;strong&gt;指令完成&lt;/strong&gt;指的是指令的所有步骤都执行完毕
   &lt;em&gt;&lt;strong&gt;取指&lt;/strong&gt;、
   &lt;strong&gt;解码&lt;/strong&gt;、
   &lt;strong&gt;执行&lt;/strong&gt;、
   &lt;strong&gt;写回&lt;/strong&gt;。&lt;/em&gt;
   这个概念是CPU制造需要用到的具体可以下次聊CPU流水线来详细了解。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;错误(Faults)&lt;/p&gt;

        &lt;p&gt;错误(Faults)是在指令&lt;strong&gt;尚未完成&lt;/strong&gt;时触发的异常。
  这是一种可以被改正的异常，发现错误之后一旦被改正之后就可以恢复正常的&lt;strong&gt;执行流&lt;/strong&gt;。当一个指令发生&lt;strong&gt;Faults类型&lt;/strong&gt;的异常的时候会把&lt;strong&gt;当前指令&lt;/strong&gt;的eip压栈保存起来，进入对应的异常处理程序，异常处理完成之后会从利用之前保存的eip中恢复原来的执行流，会从触发faults的指令开始执行。&lt;/p&gt;

        &lt;p&gt;例如：&lt;strong&gt;页面错误(page fault)&lt;/strong&gt;，&lt;strong&gt;段错误(segment fault)&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;陷阱(Traps)&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;陷阱(Traps)&lt;/strong&gt;是在指令&lt;strong&gt;已经完成&lt;/strong&gt;后触发的异常。
  这个陷阱和&lt;strong&gt;software Interrupt&lt;/strong&gt;关系也不小，&lt;strong&gt;software Interrupt&lt;/strong&gt;其实就是一个Traps类型的exception。Traps是一种不可以恢复的异常，一旦触发了traps那么&lt;strong&gt;这条指令的下一条指令&lt;/strong&gt;的eip则会被押入栈中保存。异常处理结束后会接着下面的指令恢复原来的执行流。&lt;/p&gt;

        &lt;p&gt;例如：x86-32 架构中有3个异常分别是&lt;strong&gt;#DB&lt;/strong&gt;, &lt;strong&gt;#BP&lt;/strong&gt;, &lt;strong&gt;#OF(debug exception,
  breakpoint, overflow)&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#DB (debug exception)&lt;/code&gt;
  这个既可以是&lt;strong&gt;faults&lt;/strong&gt;也可以是&lt;strong&gt;traps&lt;/strong&gt;，双重属性是为了提供断点，单步执行，数据观察。这个有很多功能之后写文章详细说明。&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#BP (breakpoint Exception)&lt;/code&gt;
  这个提供了断点为了设置断点。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int3&lt;/code&gt;是x86专门设计的单字节中断指令(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xCC&lt;/code&gt;)&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#OF (Overflow Exception)&lt;/code&gt;
  这是为了检查算数操作的&lt;strong&gt;溢出(Signed Overflow)&lt;/strong&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;into&lt;/code&gt;是为了直接出发这个&lt;strong&gt;Traps&lt;/strong&gt;(这个很少用，算数溢出在应用层就会被捕获了很少到CPU还没处理的)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;终止(Aborts)
  这里只有发生非常严重的问题的同时还才会触发的一类异常。这时候有可能连eip或者栈都被破坏了。这是一种不可恢复的异常。&lt;/p&gt;

        &lt;p&gt;Intel 提供了两种&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#MC (Machine Check，机器检查)&lt;/code&gt;
  某种严重的硬件故障。比如内存ECC校验失败。缓存一致性错误，总线传输错误，等其他不可恢复的硬件错误。这个需要读取硬件提供的MCA(Machine check architecture)寄存器获取具体错误原因。&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#DF (Double fault，双重故障)&lt;/code&gt;
  当CPU处理异常的时候又发生了异常。这个时候可以记录上下文信息。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Programmed exceptions&lt;/strong&gt;
  这个和软件中断(software interrupt)差不多，它也是由程序的指令生成的不是硬件事件引发的。他们有俩个指令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bound&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;into&lt;/code&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;into&lt;/code&gt;已经讲过了。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bound&lt;/code&gt;是为了检测数组或者数据范围是否超出指定边界
  &lt;strong&gt;第一个操作数&lt;/strong&gt;是要检查的索引或者值
  &lt;strong&gt;第二个操作数&lt;/strong&gt;是内存地址，包含两个边界值(低边界，高边界)
  如果寄存器的值小于低边界或者大于高边界，触发&lt;strong&gt;#BR(bounds check exception)&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  bound reg, mem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;中断向量一共256个，范围是0-255。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;作为执行流的中断&quot;&gt;作为执行流的中断&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;执行流&lt;/strong&gt;定义为一段正在执行的代码。
要知道一段正在执行的代码需要一些必要的外围环境作为支持。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;外围环境&lt;/strong&gt;(context)就是&lt;strong&gt;栈&lt;/strong&gt;和&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;cpu寄存器&lt;/strong&gt;来处理函数调用和一些局部变量的存储。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这次讨论着重考虑&lt;strong&gt;栈&lt;/strong&gt;的作用，在一个OS主要有如下9种&lt;strong&gt;执行流&lt;/strong&gt;,我会分别给出他们使用的&lt;strong&gt;栈&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/forg_on_interrupt_processtable.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- 
   类型                         栈类型
1. 普通进程(用户进程)           用户栈/内核栈
2. 内核进程                     内核栈

3. 中断处理程序(ISR)            内核栈/中断栈 \
4. 异常处理程序(exceptions)     内核栈        |  中断有关
5. 软中断(Softirqs&amp;amp;tasklets)    内核栈        |
6. 工作队列(work Queues)        内核栈        /

7. 信号处理程序   (*)           用户栈/信号栈
8. 异步I/O回调    (*)           用户栈/内核栈
9. 引导程序                     初始栈
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;中断的处理流程与机制&quot;&gt;中断的处理流程与机制&lt;/h3&gt;
&lt;h4 id=&quot;简要中断处理流程&quot;&gt;简要中断处理流程&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-flow&quot;&gt;hw=&amp;gt;operation: hardwares
cpu=&amp;gt;operation: CPU
pic=&amp;gt;operation: PIC
isr=&amp;gt;operation: ISRs
hw-&amp;gt;pic-&amp;gt;cpu-&amp;gt;isr
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;硬件设备&lt;/strong&gt;通过中断信号线向&lt;strong&gt;PIC&lt;/strong&gt;发出&lt;strong&gt;IRQs(Interrupt ReQuests)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PIC&lt;/strong&gt;把中断号发送给&lt;strong&gt;CPU&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CPU&lt;/strong&gt;根据中断号查询&lt;strong&gt;中断向量表(IVT/IDT)&lt;/strong&gt;执行对应的&lt;strong&gt;中断服务程序(ISR)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CPU&lt;/strong&gt;向&lt;strong&gt;PIC&lt;/strong&gt;发送处理完毕的&lt;strong&gt;信号(EOI)&lt;/strong&gt;以便中断控制器可以接受别的信号&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;硬件部分pic中断控制器和硬件设备&quot;&gt;硬件部分PIC(中断控制器)和硬件设备&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # 目前只考虑PIC的情况，如果之后Frog会支持APIC会补充APIC的新文章
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;聊中断硬件部分的时候我们需要两个硬件。一个是&lt;strong&gt;发生硬件的设备&lt;/strong&gt;,这次我选网卡。还有一个是&lt;strong&gt;PIC&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;PIC是&lt;strong&gt;用来管理不同中断和CPU通信的中介&lt;/strong&gt;，主要负责&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;接受中断请求。&lt;/li&gt;
  &lt;li&gt;判断是否转发中断请求给CPU(屏蔽检查，优先级判断，服务中检查)&lt;/li&gt;
  &lt;li&gt;发送中断服务到CPU&lt;/li&gt;
  &lt;li&gt;接受&lt;strong&gt;EOI(End of Interrupt)&lt;/strong&gt;信号&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们假设一个网卡发出一个中断请求到PIC上，网卡和PIC是通过铜线相连。
1.PIC接受中断信号。
    这时候PIC接受到网卡中断信号，中断请求记录在IRR(中断请求寄存器)中。
2.PIC判断是否通知CPU
    此时PIC会进行一系列判断，决定是否将网卡中断转发给CPU：
    1. &lt;strong&gt;IMR(中断屏蔽寄存器)&lt;/strong&gt;检查：确认该中断是否被屏蔽。
    2. &lt;strong&gt;ISR(服务中寄存器)&lt;/strong&gt;检查：查看该类型中断是否正在服务中，且CPU尚未释放中断线（通过EOI）。
    3. &lt;strong&gt;优先级判断&lt;/strong&gt;：优先级更高的中断可以打断低优先级的中断&lt;/p&gt;

  &lt;p&gt;3.PIC向CPU发送中断
    一系列判断过后，如果可以发送中断给CPU，那么PIC就会通过中断向量号告诉CPU中
    断类型(中断向量号是在PIC初始化的时候OS和PIC约定好的)。
4.CPU处理中断
    这里的操作我会在内核处理部分详细说明。之后CPU处理中断后会发送EOI信号给PIC
5.PIC接受&lt;strong&gt;EOI&lt;/strong&gt;信号
    PIC会接受到EOI信号清除ISR的标志位，释放中断线。
6.PIC检查挂起的中断
    之后PIC会检查挂起的中断，也就是刚刚因为ISR存在而没有被响应的中断，PIC检查IRR如果又挂起的中断就会继续通知CPU。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由刚刚的流程PIC在硬件层面已经做了一定程度的&lt;strong&gt;优先级&lt;/strong&gt;和&lt;strong&gt;同类型中断屏蔽&lt;/strong&gt;的功能。&lt;/p&gt;

&lt;p&gt;值得一提的是，就网卡中断来说，如果网卡中断被挂起数据包会缓存在网卡上的缓冲区中
类似的硬件都有这种功能。&lt;/p&gt;

&lt;h4 id=&quot;内核处理部分&quot;&gt;内核处理部分&lt;/h4&gt;
&lt;p&gt;CPU首先收到了来自PIC选择的中断,PIC传递来的是已经把&lt;strong&gt;IRQs&lt;/strong&gt;线号转换后的中断向量号，(这是通过数据总线传输来的)intel的CPU有一个机制叫做&lt;strong&gt;中断门&lt;/strong&gt;，CPU通过IDT(中断描述符表)CPU在得到这个中断向量后，使用中断向量号结合IDT查找到对应的中断处理程序的地址&lt;strong&gt;ISR(interrput service routine)&lt;/strong&gt;。这时候就正式进入处理函数的部分，处理中断的流程以给PIC的端 口发送&lt;strong&gt;EOI(end of interrupt)&lt;/strong&gt;为分界分为2个部分。&lt;/p&gt;

&lt;p&gt;我们稍微把CPU时间往前拨动一点到，中断还没有从PIC发送到CPU时候。我们看看OS当时在做什么，这时候OS可能处于两种情况一种是工作在&lt;strong&gt;Ring3&lt;/strong&gt;也就是&lt;strong&gt;用户态&lt;/strong&gt;，一种是工作在Ring0也就是内核态，我挑选Ring3来解释。此时工作在用户态的操作系统由于中断的突然发生打断了当前的执行流，准备越过&lt;strong&gt;中断门&lt;/strong&gt;进入IDT中记录的ISR的地址执行ISR。这时候由于CPU发现是&lt;strong&gt;Ring3-&amp;gt;Ring0&lt;/strong&gt;的权限提升所以需要借助&lt;strong&gt;TSS(Task State Segment)&lt;/strong&gt;来切换当前使用的栈从ring3栈到ring0栈。CPU自动切换栈的同时，还把Ring3时的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ss&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;esp&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eflag&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cs&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eip&lt;/code&gt; 这5个寄存器的值依次压入了内核栈也就是ring0栈栈切换完毕，ring3的寄存器压入完毕之后，由于使用了中断门，所以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EFLAG&lt;/code&gt;这个寄存器的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IF位&lt;/code&gt;自动清零用来屏蔽可屏蔽中断，这些做完之后就正式进入目标中断向量号的ISR中开始处理中断。&lt;/p&gt;

&lt;h5 id=&quot;isr部分&quot;&gt;ISR部分&lt;/h5&gt;
&lt;p&gt;由于&lt;strong&gt;ISR&lt;/strong&gt;会处理很多数据所以会尽可能的保存现场。Frog的处理方式是在每一次&lt;strong&gt;ISR&lt;/strong&gt;的时候都会&lt;strong&gt;依次&lt;/strong&gt;压入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ds&lt;/code&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;es&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gs&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pushad&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push %INR&lt;/code&gt;(最后一个是压入中断向量号)到内核栈中。
操作系统内核提供一个类似&lt;strong&gt;IDT&lt;/strong&gt;一样的&lt;strong&gt;ISR&lt;/strong&gt;的函数指针数组&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;intr_table&lt;/code&gt;这里提供一些共用的代码(因为不同架构的CPU在中断处理上的汇编有所不同)。&lt;/p&gt;

&lt;p&gt;在准备好环境之后，&lt;strong&gt;ISR&lt;/strong&gt;需要做的工作是移动一些数据到内存中,和挂起一个对应中断的&lt;strong&gt;softirq&lt;/strong&gt;，一旦这数据处理完毕ISR的工作就结束了。这是就可以调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;irq_exit()&lt;/code&gt; 结束ISR的部分。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;irq_exit()&lt;/code&gt; 主要用处是给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIC/APIC&lt;/code&gt;发送&lt;strong&gt;EOI&lt;/strong&gt;即调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ack()&lt;/code&gt;方法和查询有没有需要处理的softirqs如果有就启动对应类型的softirqs处理数据。等softirq结束之后结束整个中断运行流即调用iret。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;softirqs部分&quot;&gt;Softirqs部分&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;软中断(softirqs)&lt;/strong&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt;指令触发的不同于硬件的软件中断(software interrupt)不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先&lt;strong&gt;softirqs&lt;/strong&gt;是一种延迟处理中断的方式。我先聊一下没有softirq的时候中断如何处理我拿网络中断举例子，网络中断会根据刚刚我提到的一系列的从硬件到&lt;strong&gt;ISR&lt;/strong&gt;，拿到网络包数据，之后直接使用网络协议栈处理这个包处理完成之后，结束这个中断的执行流。紧接着再来一个网络中断又是一样拿到数据-&amp;gt;使用协议栈处理包。如果同时出现10个网络中断这样就会不停的被中断打断进行上下文切换，10次中断就需要打断10次并且每一次都需要使用网络协议栈处理数据包。如果有一种方式可以让10次中断变成只从网卡DMA拿数据到操作系统的&lt;strong&gt;FIFO&lt;/strong&gt;缓存中，最后一次一次性处理&lt;strong&gt;FIFO&lt;/strong&gt;缓存里所有的数据包。这样就节省了调用网络协议栈的时候的时间了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;softirqs&lt;/strong&gt;提供一个全局变量&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pending&lt;/code&gt;来记录不同类型的&lt;strong&gt;softirqs&lt;/strong&gt;的[挂起]状态，一旦检测到有&lt;strong&gt;softirqs&lt;/strong&gt;任务挂起，那么就会调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_softirq()&lt;/code&gt;来处理具体的任务，一般&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_softirq()&lt;/code&gt;会处理所有正在挂起的&lt;strong&gt;softirq&lt;/strong&gt;。由于&lt;strong&gt;softirq&lt;/strong&gt;是可以被打断的，所以&lt;strong&gt;softirq&lt;/strong&gt;的任务要适合打断可以重入。本质上说pending这个bitmap是在标记各个&lt;strong&gt;softirq&lt;/strong&gt;对应的处理数据源buffer有无数据的展示，另一个角度来看其实是一种&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生产-消费&lt;/code&gt;的模型，硬件中断&lt;strong&gt;ISR&lt;/strong&gt;部分是被控制不能打断的“&lt;strong&gt;生产者&lt;/strong&gt;”，而&lt;strong&gt;softirqs&lt;/strong&gt;部分是可以被打断的 “&lt;strong&gt;消费者&lt;/strong&gt;“。&lt;strong&gt;生产者&lt;/strong&gt;通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;raise_softirqs()&lt;/code&gt;来挂起某个类型(预约)一个&lt;strong&gt;消费者&lt;/strong&gt;来处理他产生的数据。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;名词解释
&lt;strong&gt;挂起(pending)&lt;/strong&gt; 一个任务暂时无法执行，因为他需要的一些条件还没有被满足。我可能会翻译为”代办”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;中断嵌套与中断优先级&quot;&gt;中断嵌套与中断优先级&lt;/h3&gt;
&lt;p&gt;中断嵌套存在两种不同定义的上下文。
1.中断嵌套的实现条件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(1) 硬件支持
PIC 或 APIC 必须支持中断优先级：
如果中断 B 的优先级高于中断 A，PIC/APIC 会通知 CPU处理新的中断。
低优先级的中断线（如 A）被屏蔽直到 B 处理完成。
(2) 内核支持
内核必须正确管理中断嵌套计数和上下文：
进入新的中断时，内核会增加嵌套计数器。
退出中断时，减少嵌套计数器，确保多层嵌套能够正确恢复。
(3) 中断屏蔽机制
通常，同一类型的中断（如同一个网卡的中断）会被内核配置为不可嵌套处理，以减少复杂性。
但不同类型或更高优先级的中断可能会被允许打断。
如果中断 B 到达而不能被响应，会发生什么？
这取决于中断控制器和内核的配置。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果中断到达而不能被响应会发生什么&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(1) 中断被屏蔽（Masked）
如果中断 B 被屏蔽（如同类型中断或低优先级中断），它将不会被响应。
中断信号可能会保持挂起，直到屏蔽解除。例如：
在 PIC 中，某条中断线被屏蔽时，即使有信号到达，PIC 不会通知 CPU。
(2) 中断被丢弃
某些硬件或驱动程序可能会忽略新的中断信号，而不会挂起等待。
例如，在一些简单的设备中，如果缓冲区已满，新的中断可能被直接丢弃。
(3) 中断队列（Interrupt Queuing）
高级中断控制器（如 APIC 或现代 SoC 的中断控制器）可能会维护一个中断队列：
当一个中断无法立即处理时，将其挂起。
等待 CPU 处理完当前任务后再触发挂起的中断。
(4) 中断 Storm 的风险
如果新的中断持续到达而无法处理，可能导致所谓的 中断风暴（Interrupt Storm）。
中断风暴会占用大量 CPU 时间，导致系统性能急剧下降
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;没有提到的内容&quot;&gt;没有提到的内容&lt;/h2&gt;
&lt;h3 id=&quot;中断栈&quot;&gt;中断栈&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x64的设备会通过tss提供一个中断栈，Frog目前是32位系统所以等升级之后再考虑这些内容。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;后&quot;&gt;后&lt;/h2&gt;

&lt;p&gt;中断栈是64位引入的新内容，也许会再之后更新或者重新整理这篇文章。现在看来这篇文章
写的不太清楚。之后可能会更改一下行文。&lt;/p&gt;

&lt;p&gt;Thu Feb 13 06:25:32 PM CST 2025&lt;/p&gt;
</description>
          <pubDate>2024-12-11T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/frog/2024/12/11/on_interrupt.html</link>
          <guid isPermaLink="true">http://localhost:4000/frog/2024/12/11/on_interrupt.html</guid>
        </item>
      
    
      
        <item>
          <title>qemu上网指南</title>
          <description>&lt;h1 id=&quot;如何使用bridge连接qemu虚拟机和宿主机&quot;&gt;如何使用bridge连接qemu虚拟机和宿主机&lt;/h1&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#本机环境
uname -a
Linux k 6.2.0-37-generic #38.22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Thu Nov 2 18:01:13 UTC 2 x86_64 x86_64 x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # 安装虚拟网桥工具 brctl
sudo apt install bridge-utils -y
 # 安装(user-mode linux)工具 tunctl
sudo apt install uml-utilities -y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;配置网桥--qemu设置&quot;&gt;配置网桥 &amp;amp; qemu设置&lt;/h2&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# &amp;lt;user&amp;gt; 当前user名字&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# &amp;lt;enp0&amp;gt; 需联网的网卡&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# &amp;lt;bridge ip&amp;gt; 设置符合你当前网络网段的IP地址(可以和enp0网卡一样)&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;brctl addbr br0
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;tunctl &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; tap0 &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; &amp;lt;user&amp;gt; 
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;brctl addif br0 tap0 &amp;lt;enp0&amp;gt; 
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;ip addr add &amp;lt;bridge ip&amp;gt; dev br0 
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;ip &lt;span class=&quot;nb&quot;&gt;link set&lt;/span&gt; &amp;lt;enp0&amp;gt; up
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;tap0 up
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 设置qemu的网络前端设备和后端设备
qemu-system-i386 \ 
-netdev tap,id=net0,ifname=tap0,script=no,downscript=no \
-device e1000,netdev=net0 \
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;get-your-hands-dirty&quot;&gt;Get your hands dirty&lt;/h1&gt;

&lt;h2 id=&quot;如何让qemu虚拟机可以连接网络&quot;&gt;如何让qemu虚拟机可以连接网络？&lt;/h2&gt;
&lt;p&gt;虚拟机连接网络需要两种必要条件，一个是硬件，一个是软件。硬件是网卡，软件就是一整套协议栈和网卡驱动。当虚拟机已经具有最基本条件之后，就需要&lt;strong&gt;外围网络设备&lt;/strong&gt;保障网络连接，qemu提供了5种上网策略&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;User Networking (NAT)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Tap Networking&lt;/strong&gt; (Bridge Networking)&lt;/li&gt;
  &lt;li&gt;Socket Networking&lt;/li&gt;
  &lt;li&gt;Macvtap Networking&lt;/li&gt;
  &lt;li&gt;Host Networking&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我选用了第二种策略。
&lt;strong&gt;Tap Networking&lt;/strong&gt; (Bridge Networking) 这种联网方式是通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tap&lt;/code&gt;设备将虚拟机和宿主机的&lt;strong&gt;网桥&lt;/strong&gt;上，虚拟机和宿主机通过网桥连接。这样宿主机可以通过网桥&lt;strong&gt;转发&lt;/strong&gt;虚拟机流量从而共享宿主机的网卡。这一套外围设备是宿主机提供的，让我们一步一步设置。&lt;/p&gt;

&lt;h2 id=&quot;外围设备&quot;&gt;外围设备&lt;/h2&gt;
&lt;p&gt;先看一下初始网络接口信息&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip addr show 
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: enp0s31f6: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether xx:xx:xx:68:ca:24 brd ff:ff:ff:ff:ff:ff

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;实体网卡&lt;strong&gt;enps31f6&lt;/strong&gt;就是可以链接网络的网卡。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;新建一个网桥&lt;strong&gt;br0&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;brctl addbr br0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;新建一个叫做&lt;strong&gt;tap0&lt;/strong&gt;的tap接口&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;tunctl &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; tap0 &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; &amp;lt;user&amp;gt;
&lt;span class=&quot;c&quot;&gt;# 设置tap0 UP&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;up dev tap0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里的&lt;user&gt;填写允许访问这个tap0接口的用户&lt;/user&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;这时候的网络接口情况&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;ip addr show
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: enp0s31f6: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether 9c:2d:cd:68:ca:24 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.14/24 brd 192.168.1.255 scope global dynamic enp0s31f6
       valid_lft 604042sec preferred_lft 604042sec
11: br0: &amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state DOWN group default qlen 1000
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether 56:a6:1d:0c:23:17 brd ff:ff:ff:ff:ff:ff
12: tap0: &amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state DOWN group default qlen 1000
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether 26:a8:e6:ba:b0:cd brd ff:ff:ff:ff:ff:ff
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;p&gt;把网卡和tap0接口都添加到网桥上&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;brctl show
bridge name	bridge &lt;span class=&quot;nb&quot;&gt;id		&lt;/span&gt;STP enabled	interfaces
br0		8000.56a61d0c2317	no
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;网桥&lt;strong&gt;br0&lt;/strong&gt;被添加接口前&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;brctl addif br0 tap0 enp0s31f6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;brctl show
bridge name	bridge &lt;span class=&quot;nb&quot;&gt;id		&lt;/span&gt;STP enabled	interfaces
br0		8000.56a61d0c2317	no		 enp0s31f6
							         tap0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;网桥&lt;strong&gt;br0&lt;/strong&gt;被添加接口后&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本来联网的网卡&lt;strong&gt;enp0s31f6&lt;/strong&gt;就不会在处理数据包了他的ip地址也会不见，现在的网络接口信息如下&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: enp0s31f6: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc fq_codel master br0 state UP group default qlen 1000
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether 9c:2d:cd:68:ca:24 brd ff:ff:ff:ff:ff:ff
11: br0: &amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state DOWN group default qlen 1000
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether 56:a6:1d:0c:23:17 brd ff:ff:ff:ff:ff:ff
12: tap0: &amp;lt;BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noop master br0 state DOWN group default qlen 1000
    &lt;span class=&quot;nb&quot;&gt;link&lt;/span&gt;/ether 26:a8:e6:ba:b0:cd brd ff:ff:ff:ff:ff:ff
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时候需要给网桥分配一个适合你网段的ip地址，或者使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo dhclient br0&lt;/code&gt;给&lt;strong&gt;br0&lt;/strong&gt;提供一个ip地址。
到这里宿主机的外围设备配置就结束了。
##qemu配置&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	qemu-system-i386 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;-monitor&lt;/span&gt; stdio &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; 1G &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;-hda&lt;/span&gt; ubuntu-disk.img &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;-rtc&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;localtime,clock&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;host &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;-netdev&lt;/span&gt; tap,id&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;net0,ifname&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;tap0,script&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;no,downscript&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;no &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; e1000,netdev&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;net0 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;-audiodev&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;alsa,driver&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;alsa &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;-machine&lt;/span&gt; pcspk-audiodev&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;alsa &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;-cdrom&lt;/span&gt; ./ubuntu-14.04.6-server-i386.iso
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;关键的就是对网络设备的配置，
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-netdev tap,id=net0,ifname=tap0,script=no,downscript=no
 -device e1000,netdev=net0&lt;/code&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-netdev&lt;/code&gt;用于指定网络后端实现，这里是用&lt;strong&gt;tap&lt;/strong&gt;接口实现，&lt;strong&gt;ifname&lt;/strong&gt;这个选项对应的接口
就是刚刚宿主机新建的tap接口&lt;strong&gt;tap0&lt;/strong&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-device&lt;/code&gt;则是配置网卡
和使用指定的netdev实现。&lt;/p&gt;

&lt;p&gt;#Troublesh0oting&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;网桥配置完全之后只有二层协议可以通过但是三层协议被丢包，怎么解决？ 
有可能是你的宿主机的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iptables&lt;/code&gt;拦截了流量，查看iptable的规则，或者直接关闭
 网桥转发数据的包经过iptables处理。查看这两个文件是不是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;设成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;关闭。
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat /proc/sys/net/bridge/bridge-nf-call-iptables
    cat /proc/sys/net/bridge/bridge-nf-call-ip6tables&lt;/code&gt;
 你也可以编辑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/sysctl.conf&lt;/code&gt; 添加&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; net.bridge.bridge-nf-call-iptables &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo sysctl -p&lt;/code&gt;应用修改来永久修改这个配置项 
 或者&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Unit]
 &lt;span class=&quot;nv&quot;&gt;Description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Setup qemu network bridging
  &lt;span class=&quot;nv&quot;&gt;After&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;network-online.target
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Service]
&lt;span class=&quot;nv&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;oneshot
&lt;span class=&quot;nv&quot;&gt;Restart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;on-failure
&lt;span class=&quot;nv&quot;&gt;ExecStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;brctl addbr virtbr0
&lt;span class=&quot;nv&quot;&gt;ExecStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;brctl addif virtbr0 enp3s0
&lt;span class=&quot;nv&quot;&gt;ExecStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ip addr add 192.168.0.20/24 dev virtbr0
&lt;span class=&quot;nv&quot;&gt;ExecStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;virtbr0 up
&lt;span class=&quot;nv&quot;&gt;ExecStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;iptables &lt;span class=&quot;nt&quot;&gt;-I&lt;/span&gt; FORWARD &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; physdev &lt;span class=&quot;nt&quot;&gt;--physdev-is-bridged&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-j&lt;/span&gt; ACCEPT
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Install]
&lt;span class=&quot;nv&quot;&gt;WantedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;你可能需要给tap0和br0配置promisc启动混杂模式来监听流过他们的所有&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;promisc on dev tap0
   &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;ip &lt;span class=&quot;nb&quot;&gt;link set &lt;/span&gt;promisc on dev br
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.qemu.org/Documentation/Networking&quot;&gt;1&lt;/a&gt; QEMU Networking&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://lifeislife.cn/posts/qemu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/&quot;&gt;2&lt;/a&gt; QEMU 虚拟机网络配置&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/extremecoders-re/e8fd8a67a515fee0c873dcafc81d811c&quot;&gt;3&lt;/a&gt; Setting up Qemu with a tap interface&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.spad.uk/posts/really-simple-network-bridging-with-qemu/&quot;&gt;4 &lt;/a&gt;这里提到了iptables转发流量的设置&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.junmajinlong.com/virtual/network/all_about_tun_tap/&quot;&gt;更多关于tap/tun&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;后&quot;&gt;后&lt;/h3&gt;
&lt;p&gt;虽然设置好虚拟机的网卡但一直没有几乎添加协议栈内容;*(，希望有几乎实现协议栈。&lt;/p&gt;

&lt;p&gt;Thu Feb 13 05:37:47 PM CST 2025&lt;/p&gt;
</description>
          <pubDate>2024-12-09T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/2024/12/09/network_bridging_with_qemu.html</link>
          <guid isPermaLink="true">http://localhost:4000/2024/12/09/network_bridging_with_qemu.html</guid>
        </item>
      
    
      
        <item>
          <title>新造的轮子</title>
          <description>&lt;h1 id=&quot;新造的轮子-neovim&quot;&gt;新造的轮子? neovim!&lt;/h1&gt;
&lt;p&gt;这是一系列谈论neovim的文章的第一章，我们在谈论它之前我想先梳理一下文本编辑器的历史。
从1960年代到现在，整个编辑器大概可以划分为四个时代。&lt;/p&gt;

&lt;h2 id=&quot;起源时代-1960s-1970s&quot;&gt;起源时代 (1960s-1970s)&lt;/h2&gt;
&lt;p&gt;文本编辑器的历史和计算机历史重合，当早期的计算机女工们不在依赖打孔卡输入和计
算机交互时，随之而来就是与终端交互的的文本编译器的元年—1965年，一种 行编辑器
ED 出现了。1960s-70s的计算机使用者大多数是学者或者军事人员和大型企业的财务计算人
员等。当时人和计算机的交互从打孔卡(punched paper tape)慢慢过渡到交互式终端(teletype，tty)
在没有CRT显示器的时期所有的交互都是打印在纸上的。当时计算机设备比如PDP-11的早期型
号只有几KB的内存，由于内存限制没法把所有文本都载入内存，所以当时的文本编辑器是
&lt;strong&gt;行编辑&lt;/strong&gt;(line-oriented) 或者是&lt;strong&gt;面向字符编辑&lt;/strong&gt;(character-oriented)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/f/f0/DEC_PDP-1_Demo_Lab_at_Mountain_View%27s_Computer_History_Museum.jpg&quot; alt=&quot;PDP-1&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;上图就是PDP-1的样子，桌面上类似打字机的设备就是teletype&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div style=&quot;background-color:#d0e7f9; color:#4d4d4d; padding:10px; border-radius:5px;&quot;&gt;
这里我想到一个题外话60年代也是UNIX的出现的年代，
UNIX比较有特点的是它以字符串作为程序间交互的介质而不是数据结构
也许也受限于当时的内存大小。
&lt;/div&gt;

&lt;h3 id=&quot;teco&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/TECO_(text_editor)&quot;&gt;TECO&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;1962年，TECO(Text Editor &amp;amp; Corrector)是在PDP-1机器上&lt;strong&gt;面向字符(character-oriented)&lt;/strong&gt;
的&lt;em&gt;编辑器&lt;/em&gt;也是一种&lt;em&gt;编程语言&lt;/em&gt;。TECO提供了&lt;strong&gt;Macro&lt;/strong&gt;以提供对文本的搜索和修改，这个功能也被
Emacs吸收并发扬光大。同时TECO也提出了一种哲学&lt;a href=&quot;http://catb.org/jargon/html/Y/YAFIYGI.html&quot;&gt;YAFIYGI&lt;/a&gt;(You Asked For It, You Got It),
这个理念和编辑器之后&lt;a href=&quot;https://en.wikipedia.org/wiki/WYSIWYG&quot;&gt;WYSIWYG&lt;/a&gt;(What You See Is What You Get)有明显不同，
我也许会在之后有关UX的文章中讨论WYSIWYG。
YAFIYGI 反应了早期编辑器的设计哲学&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;用户输入的每一个命令都严格执行，不会提供保护和帮助&lt;/li&gt;
  &lt;li&gt;编辑器不会纠正用户的错误
这种设计哲学强调了用户对操作负责。强调功能的同时也兼具了效率。&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;background-color:#d0e7f9; color:#4d4d4d; padding:10px; border-radius:5px;&quot;&gt;
一定程度上TECO这个哲学和,C语言相信程序员的C代码哲学相似，这种哲学是有意为之还是
条件所迫呢？
&lt;/div&gt;

&lt;h3 id=&quot;qed&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/QED_(text_editor)&quot;&gt;QED&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;1965-1966年，在加州伯克利大学开发的Berkeley Timesharing System上由Butler Lampson 、
L. Peter Deutsch和Dana Angluin三人一起开发的&lt;strong&gt;行编辑器&lt;/strong&gt;QED（quick editor）即使QED
当时只是为了电传打字机开发并没有考虑CRT显示的场景也大幅提升了当时的人机交互体验。
QED也对后来的文本编辑器例如 &lt;em&gt;sed&lt;/em&gt; 、&lt;em&gt;ex&lt;/em&gt; 、&lt;em&gt;awk&lt;/em&gt; 、&lt;em&gt;perl&lt;/em&gt;有着影响。&lt;/p&gt;

&lt;h2 id=&quot;前现代编辑器时代-1970s-1980s&quot;&gt;前现代编辑器时代 (1970s-1980s)&lt;/h2&gt;
&lt;p&gt;随着70年代,PDP和IBM360的普及以及视频终端对电传打字机的替代，更多机构可以负担的起
交互式计算设备，分时系统和UNIX也给多个用户共享计算机资源提供了支持，也促进了交互
式工具的发展，慢慢的面向行编辑的编辑器就不能满足对完整文件操作的需求了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/a/af/DM_IBM_S360.jpg&quot; alt=&quot;IBM S360&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;上图就是大型机时代开山之作&lt;strong&gt;IBM System/360 Model 20&lt;/strong&gt;，IBM当时项目负责人Frederick P. Brooks,
Jr.根据此项目的开发经验写出了&lt;a href=&quot;https://en.wikipedia.org/wiki/The_Mythical_Man-Month&quot;&gt;《人月神话：软件项目管理之道》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;vi和ex&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Vi_(text_editor)&quot;&gt;Vi&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Ex_(text_editor)&quot;&gt;Ex&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;1976年UC Berkeley的学生&lt;strong&gt;Bill Joy&lt;/strong&gt;，在修改当时UNIX系统上的Pascal编译器发现ed编辑器实
在不好用。没多久他就和同学Chuck Haley写了第一个编辑器&lt;em&gt;en&lt;/em&gt;，后来他们扩展了这个编辑器
开发出了&lt;strong&gt;ex&lt;/strong&gt;。77年的10月份，Bill joy给ex添加了全屏模式(full-screen visual mode)这就
是我们熟悉的 &lt;strong&gt;vi&lt;/strong&gt; 由此可知ex和vi这两个编辑器是共享一部分代码的，vi就是一个拥有全屏显
示功能的 ex，而&lt;strong&gt;vi(VIsual mode)&lt;/strong&gt;的名字就是ex的一个全屏幕显示模式的前两个字母。1979
年因为大多是人只使用ex的Vi模式,Bill Joy就给ex的Vi模式创建一个快捷方式，这就是后世
知道的Vi的起源了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/7/77/Adm3aimage.jpg&quot; alt=&quot;ADM-3A&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;上图就是Bill 当时开发Vi的时候使用的设备 还是可以辨认出hjkl上是有方向键的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于Bill Joy使用&lt;a href=&quot;https://en.wikipedia.org/wiki/ADM-3A&quot;&gt;ADM-3A&lt;/a&gt;开发Vi，所以Vi的按键映射和ADM-3A的键盘一致
这个时期的Vi只有基本的移动命令(hjkl)操作命令和行范围操作&lt;/p&gt;

&lt;h3 id=&quot;sed&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sed&quot;&gt;sed&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作为一个最早支持正则表达式的文字处理软件,sed继承了ed和qed的交互模式&lt;/p&gt;
&lt;div style=&quot;background-color:#d0e7f9; color:#4d4d4d; padding:10px; border-radius:5px;&quot;&gt;
我这里想写一些注脚，sed、awk和perl作为常用的字处理程序直到现在都被运维们长时间使用
&lt;/div&gt;

&lt;h2 id=&quot;黄金时代-1980s-1990s&quot;&gt;黄金时代 (1980s-1990s)&lt;/h2&gt;
&lt;p&gt;1980s-1990s这个时期是计算机技术的黄金时代，所有现在使用的基础技术都是在这个时代奠基
然后发展的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/a/a6/IBM_PC-IMG_7271_%28transparent%29.png&quot; alt=&quot;IBM Personal Computer&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;上图就是IBM PC搭载了Intel的畅销CPU intel8088 @ 4.77MHz 最高可扩展出640KB的内存
空间,也搭载了一个CGA用于显示图像，当时售价US$1,565&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;硬件上,81年IBM推出了标志着个人计算机时代的&lt;strong&gt;IBM PC&lt;/strong&gt;，著名的动画《&lt;a href=&quot;https://en.wikipedia.org/wiki/Steins;Gate&quot;&gt;命运石之门&lt;/a&gt;》
中的未来人寻找的就是这个台机器。intel的x86系列也不断的在提升CPU的性能，硬盘容量
也从MB增长到了GB。随着性能的升高硬件成本并没有随之升高而是降低。&lt;/p&gt;

&lt;p&gt;软件上，1983年由于&lt;strong&gt;Richard stallman&lt;/strong&gt; &lt;a href=&quot;https://www.gnu.org/&quot;&gt;GNU&lt;/a&gt;项目的发起，开源软件和自由软件运动被推动,
UNIX也在各个企业和科研单位占据主流平台地位。因为个人电脑的普及1981年专门针对个人
电脑的操作系统MS-Dos推出, 1991年linux内核也首次发布。&lt;/p&gt;

&lt;p&gt;由于硬件和软件上的井喷式的发展，人们对于文本编辑器在编程辅助需求进一步增加。针对当时
的需求，可扩展变成当时编辑器的主要需求。随之而来的就是两个编辑器或者两个宗教&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Editor_war&quot;&gt;Editor_war&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;gnu-emacs&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_Emacs&quot;&gt;GNU Emacs&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Emacs 是1976年由&lt;strong&gt;David A.Moon&lt;/strong&gt; 和&lt;strong&gt;Guy L.Steele jr&lt;/strong&gt;编写的以文本宏为主的编辑器，文本宏
的灵感来源于上文在元初时代提到的TECO编辑器，Emacs也是(Editing MACros)的缩写。
Emacs支持一种Lisp的方言Emacs lisp用于其插件的编写。&lt;/p&gt;

&lt;h3 id=&quot;vim&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Vim_(text_editor)&quot;&gt;Vim&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Vim是1991年由&lt;strong&gt;Bram Moolenaar&lt;/strong&gt;发布的一款高度可配置的文本编辑器。由于当时自由软件风潮
，Vim同时也是一个Charityware，从发布之初Bram Moolenaar就鼓励用户捐款给ICCF基金会
以资助乌干达儿童,而Vim也开创了charityware这个软件分发模式。&lt;/p&gt;

&lt;h4 id=&quot;vim爸爸我是怎么出生的&quot;&gt;Vim：爸爸我是怎么出生的？&lt;/h4&gt;
&lt;p&gt;Bram moolenaar是一个荷兰人，90年代的时候在一家印刷公司上班，当时他买了一台&lt;a href=&quot;https://en.wikipedia.org/wiki/Amiga&quot;&gt;Amiga&lt;/a&gt; 
电脑以 {这里加一个amiga的图片}便学习UNIX,当时在Amiga上是没有好用的Vi，Bram
moolenaar 就在已经有的软件Stevie的基础上准备复刻Vi, 所以最开始Vim是Vi IMitation
的简称，直到1992年Vim 1.22版本之后Vim正式移植到UNIX后改名为我们熟知的Vi IMproved。
就这样Bram moolenaar参与了Vim从1991年发布第一版本到2023年的Vim8.0的开发维护工作直
到他因病去世。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/c/c3/Amiga500_system.jpg&quot; alt=&quot;amiga&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;当时bram 使用的个人电脑&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div style=&quot;background-color:#d0e7f9; color:#4d4d4d; padding:10px; border-radius:5px;&quot;&gt;
就像Vim的名字一样(Vi IMproved)Vim是我们刚刚提到的bill joy开发的Vi的增强版。主要
增加了10个features &lt;br /&gt;

1. 多级撤销   2. 文本对象 &lt;br /&gt;
3. 多窗口     4. 多缓冲区 &lt;br /&gt;
5. 语法高亮   6. Visual mode &lt;br /&gt;
7. 持久性撤销 8. 插件系统 &lt;br /&gt;
9. 扩展了命令 10. 支持鼠标 &lt;br /&gt;

关于Vim的功能都会单独文章介绍
&lt;/div&gt;

&lt;h2 id=&quot;现代编辑器时代-2000s-至今&quot;&gt;现代编辑器时代 (2000s-至今)&lt;/h2&gt;
&lt;p&gt;千禧年后的时代由于GUI和Web的普及，基于现代图形界面的文本编辑器占据了主流地位。对于
文本编辑器的基本需求已经在90年代这10年完成了奠基。之后的软件都是选择某些feature特化
某些能力。你在这个时代看到的新编辑器一定有Vim或者Emacs的影子。
&lt;em&gt;sublime Text 2008&lt;/em&gt; , &lt;em&gt;atom 2015&lt;/em&gt;, &lt;em&gt;VS Code 2015&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;doc.cat-v.org/unix/unix-before-berkeley&quot;&gt;A History of UNIX before Berkeley: UNIX Evolution: 1975-1984&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://pikuma.com/blog/origins-of-vim-text-editor&quot;&gt;Understanding the Origins and the Evolution of Vi &amp;amp; Vim&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;后&quot;&gt;后&lt;/h2&gt;

&lt;p&gt;一部编辑器的历史就是计算机的历史也是开发者的历史，希望之后也可以继续这个系列&lt;/p&gt;

&lt;p&gt;Thu Feb 13 05:49:58 PM CST 2025&lt;/p&gt;

</description>
          <pubDate>2024-11-20T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/nvim/2024/11/20/history_of_text_editor.html</link>
          <guid isPermaLink="true">http://localhost:4000/nvim/2024/11/20/history_of_text_editor.html</guid>
        </item>
      
    
      
        <item>
          <title>nXt-pixel-dungeon-day2</title>
          <description>&lt;p&gt;Day 2 
  In day1 I saied that i couldn’t find a good C-based library like libgdx,
Fortunately, I found 2 different C-based libraries work on home brew switch
development. There are [raylib-nx] and [sdl2], by the way, because [ ChatGPT]
is on trending , I will using it while developing the project.
  Let’s test the 2 libraries. 
First, [raylib-nx]: &lt;a href=&quot;https://github.com/luizpestana/raylib-nx/wiki/Working-on-Switch&quot;&gt;here&lt;/a&gt;is a lead&lt;/p&gt;

</description>
          <pubDate>2023-02-11T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/homebrew/2023/02/11/nXt-pixel-dungeon-day2.html</link>
          <guid isPermaLink="true">http://localhost:4000/homebrew/2023/02/11/nXt-pixel-dungeon-day2.html</guid>
        </item>
      
    
      
        <item>
          <title>nXt-pixel-dungeon-day1</title>
          <description>&lt;p&gt;Day 1&lt;/p&gt;

&lt;p&gt;Recently, I’ve been unable to stop playing the RPG game “Shattered Pixel Dungeon” ([SPD]). It’s a rogue-like game where you play as a hero (with four different occupations) exploring the secrets of a dungeon. The game has a port for the &lt;a href=&quot;https://github.com/00-Evan/shattered-pixel-dungeon&quot;&gt;switch platform&lt;/a&gt;, but I want to create a new version specifically for the switch that includes more Joycon features.&lt;/p&gt;

&lt;p&gt;I don’t have any experience in game development, so this will be a challenge for me. But as the saying goes, a good beginning is half the battle, so I’ll start by listing some goals for version 0.1:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A single hero class: Warrior
No audio
One original boss
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[SPD] is an open-source game and its code can be obtained from Github. It’s based on the source code of &lt;a href=&quot;https://github.com/00-Evan/pixel-dungeon-gradle&quot;&gt;Pixel Dungeon&lt;/a&gt; by &lt;a href=&quot;https://pixeldungeon.tumblr.com/&quot;&gt;Watabou&lt;/a&gt; and both games were written using the Java library &lt;a href=&quot;https://libgdx.com&quot;&gt;libgdx&lt;/a&gt;. However, I want to practice my C programming skills, so I plan to rewrite the game using C and release it on the &lt;a href=&quot;https://github.com/00-Evan/shattered-pixel-dungeon&quot;&gt;switch platform&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After a long search, I couldn’t find a good C-based library for the homebrew &lt;a href=&quot;https://github.com/00-Evan/shattered-pixel-dungeon&quot;&gt;switch platform&lt;/a&gt; that is similar to &lt;a href=&quot;https://libgdx.com&quot;&gt;libgdx&lt;/a&gt;. If you have any suggestions, please let me know. I have chosen to use a 2D vector drawing library on top of OpenGL, named &lt;a href=&quot;https://github.com/memononen/nanovg&quot;&gt;nanovg&lt;/a&gt;, for the UI and visualizations.&lt;/p&gt;

</description>
          <pubDate>2023-02-09T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/homebrew/2023/02/09/nXt-pixel-dungeon-day1.html</link>
          <guid isPermaLink="true">http://localhost:4000/homebrew/2023/02/09/nXt-pixel-dungeon-day1.html</guid>
        </item>
      
    
      
        <item>
          <title>风暴般的魔女</title>
          <description>&lt;p&gt;我很喜欢香子这种性格豪放如暴风雨般的妹子，敢爱敢恨。&lt;/p&gt;

&lt;p&gt;也许是她自我的心理补偿，
也许只是为了获得关注而产生的报复心理，
她爱上了自己爸爸的师弟一个有妻子的男人。&lt;/p&gt;

&lt;p&gt;她像工艺玻璃杯一样透明脆弱的心才是她本身吧，
零的到来加剧了自己父亲对于香子的忽视，也加剧了香子更加冲动的反抗为了获得父亲更多的关注，到最后选择离开家。
对于香子来说，零的到来如同开始了一场不会结束的梦魇，零的天赋和努力越来越盖过香子，爸爸的关心全都会被这个爸爸的入室弟子所抢走，无声的反抗成为香子唯一和父亲沟通的方式。香子对零的恶意到达顶点的时候应该就是那次零在饭桌上叫自己爸爸『爸爸』那次吧。那次香子终于确信了自己真的被这个外来的小孩抢走了爸爸，最让人气愤的其实是香子爸爸的态度，父亲根本没有理会家中孩子们的想法反而是转移话题称赞零。
时间来到零多次连败的节点，那一天香子特地来拜访零的出租屋，香子一下戳破的零不让她进屋去的谎言，几番寒暄之后，能够感受到姐姐对于零并不是像刚刚我们说的那样只有恨了，她会感叹自己和零一起生活了10年却不知道零喜欢河流；会抱着零新收到的羽绒被说的确没有零的味道。这些细节足以表明姐姐，一定在哪个我们不知道的时间节点对零有了新的感受。之后他们说到了后藤，那个姐姐说自己喜欢的男人。零又一次的询问香子『就这么喜欢后藤？』，香子面带戏谑的回答『喜欢啊，最喜欢了！』&lt;/p&gt;

&lt;p&gt;从这里我可以看到的是，姐姐说自己喜欢后藤的行为很像在对父亲和零报复的行为。因为零和父亲都是爱自己的，香子用这样的行为既获得了父亲的关注又一次次不让零有负罪感（零认为自己把香子变成这样），越来越出格慢慢的变成了香子的武器，这把武器攻击了她最想攻击的两个人，所以香子现在不会放弃对后藤的追求的。如果没有追求后藤这件事情，香子就会变成一个『手无寸铁』没有办法反抗命运的人，以香子暴风般的性格她不会变成这样的。&lt;/p&gt;

&lt;p&gt;这里香子提出了零对战的那个松永先生，一个年过半百的C1选手。如果零在这场打败他，那他就再也不是职业选手不能参加排名赛了，说完这些话之后香子就大步离去了。
零在最后说的话耐人寻味『离开而去的他的发丝，被阳光穿透的瞬间微微地闪闪发光，然后，那道光芒终究还是带来了倾盆大雨』。也许，香子的到来，让零的内心有那么一丝的温暖，可这样的温暖是暂时的，带来的是香子为了报复零带来的大雨。&lt;/p&gt;

&lt;p&gt;对战松永先生之后，香子以手表丢在零的公寓为理由又一次约零见面。香子种种细节上真的表现出一个姐姐的细心，香子能轻松的说出零今年只有一个和安井先生的对局（又一次戳破了零的谎言），并且指出如果他输棋那零又一次间接的摧毁了一个家庭。&lt;/p&gt;

&lt;p&gt;香子这两次拜访，意图不是让零输掉棋局，单纯是利用零心中对于自己的愧疚对于零的报复。这也体现了香子敢爱敢恨的性格&lt;/p&gt;

&lt;p&gt;最后零回忆起，香子离家出走的那次场景。香子一边胡乱的收拾着行李，一边说我爱那个男人要离家出走。零试图阻止她
『爸爸不会原谅你的。』
『我也不会原谅他的。』大颗大颗的泪珠从香子的脸上滚下来，
零说『那我离开，我不管去哪 都不会有人担心 但是姐姐不是，姐姐是有家人的，爸爸不可能不疼爱你』&lt;/p&gt;

&lt;p&gt;这一幕就能看出，姐姐有一瞬间像原谅零的样子。其实零并不是为了抢走爸爸而存在的，而且他真的离开这个家了。零这句话会变成姐姐原谅零的原因的。&lt;/p&gt;

&lt;p&gt;这一季姐姐的最后一次出场是在零陪岛田参加前夜祭之后。因为姐姐认为零告诉爸爸自己的男友的秘密，来兴师问罪。这次零没有像之前一样只有忍受，而是选择和姐姐争吵，不巧碰上了想要给零送新做的豆皮寿司的三姐妹。识趣的大姐领着大家回去了，可二妹坚持把寿司盒送到了零的手上，香子在询问之后又冷嘲热讽的说零又在别家装可怜了。&lt;/p&gt;

&lt;p&gt;以零的性格，姐姐当然理所应当的进了家门，大口大口的吃着三姐妹的寿司还时不时的评价起来。这里有个细节，姐姐再吃筑前煮的时候一次就吃出这是韩式做法，可见姐姐至少也是懂得食物的人。
夜深之后，香子又住在零家里，这次香子慢慢展现自己的弱势面给零了，她也不知道为什么喜欢那个比自己大20岁的人，也不知道如何和父亲说这些事情。
被桃子妹妹说是魔女的她何尝不想要一个爱自己的人呢？
苦苦追寻那个自己『爱』的人，到底是为了报复父亲和零还是因为爱呢？
香子的心中是空虚的，一切来得都太简单了，父亲因为对自己的愧疚对自己好，零因为对自己的愧疚在感情上给予香子最温柔的对待，只有在那个不爱自己的人那里才能的到经历挫折获得感情的感受。香子也许是这么想的把，正事因为什么事情来得都太简单了，让她变成这样虚无，这样无望，这样辛苦。&lt;/p&gt;

&lt;p&gt;这部剧中我最喜欢香子这个角色，无论是她的敢爱敢恨，她的无望虚无，都向我展现了一个立体又生动的形象，她有时让人气愤，有时让人怜爱，&lt;/p&gt;

&lt;p&gt;父母去世的零寄住在养父家，作为留下的契约，零走向了唯一可以活下去的路，下棋。于是渐渐地零凭借着将棋天赋和努力在棋力上压过了同以棋手为目标的姐姐香子，和弟弟步。
无论在哪个方面香子都展现出宛如暴风雨般激烈，棋风也好，性情也好，她的美貌也是。&lt;/p&gt;

&lt;p&gt;这篇文章想就此分析 香子这个 如风暴般的魔女&lt;/p&gt;

&lt;p&gt;1.第一次出现在第五集交代姐姐像暴风雨一样的性格（零的回忆）
2.第二次出现在第八集，零需要对战一个老爷子之前（现实）
3.第三次出现在第十集，零对战一个家庭破裂的棋手之前（现实）
4.第四次出现在第十五集，在零的记忆里，姐姐似乎是喜欢零的（零的回忆）
5.第五次出现在第十七集，姐姐认为零对爸爸说了 自己的秘密来找零吵架，并且被三姐妹看见（现实）&lt;/p&gt;

</description>
          <pubDate>2017-04-16T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/lasay/2017/04/16/%E9%A3%8E%E6%9A%B4%E8%88%AC%E7%9A%84%E9%AD%94%E5%A5%B3.html</link>
          <guid isPermaLink="true">http://localhost:4000/lasay/2017/04/16/%E9%A3%8E%E6%9A%B4%E8%88%AC%E7%9A%84%E9%AD%94%E5%A5%B3.html</guid>
        </item>
      
    
      
        <item>
          <title>杂记 ------ 这是什么标题</title>
          <description>&lt;p&gt;其实也没有什么想要记录的，就是想点开这个App看看写写感受一下，让自己沉浸其中。
冬天的晚上总是这么难熬，南方的冬天和北方不同（其实我没有资格说这个话，我只在北方度过过夏天我根本不知道北方的冬天是什么样子的），我也只能不能免俗的跟着大家说一声不同，而且还能煞有其事的找到一个两个真像什么样子的理由，像什么寒风刺骨呀什么水汽的饱和程度呀什么，其实怎么样呢，就算如此抱怨自己不还是在这里度过了20个冬夏也没有觉得度日如年，也不知道现在的人怎么了，有人说是大家矫情了不愿意吃苦，有人说我们应该提高国民素质云云。也许懒惰爱占便宜是写在我们的基因里面的。从某种意义上来说这么多年的选择没有筛选掉这样的品质，说明这些品质最少是可以为个体谋得利益的，所以携带这样的基因的人，或者是个体才能存活下来。也许从这个角度人们常说的7宗罪或者什么恶可能是优点呢。
哈，果然存活和道德根本就不是一个位面的东西，每一个个体都想要利益最大化可是往往在这个环境下得问题都不具有贪婪选择性质也就是说个体的一个人或者说一部分人不能得到才能保证别的个体获得资源，所以才出现了阶级关系吧。
我都不知道我在讨论个什么东西了。今天就这样吧，我也没有什么想写的了，总之，晚安，好梦。&lt;/p&gt;

&lt;p&gt;Niclas @宿舍’ 2013.12.30 00:00&lt;/p&gt;

</description>
          <pubDate>2016-12-30T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/essay/2016/12/30/%E6%9D%82%E8%AE%B0.html</link>
          <guid isPermaLink="true">http://localhost:4000/essay/2016/12/30/%E6%9D%82%E8%AE%B0.html</guid>
        </item>
      
    
      
        <item>
          <title>白 ---------- 全即一，一即全</title>
          <description>&lt;p&gt;白，一直是一种有意思的东西。它大部分时间是通过一种叫做『白色』的东西展现出来的。《夏目友人帐》有一集出现的日式新娘礼服叫做无白垢，貌似这种传统服饰的意思是为了不让女子长发中的凶灵因嫉妒化为恶鬼。可见，白色在很多是时候有着净化，控制的意义。&lt;/p&gt;

&lt;p&gt;今天，给大家带来的是我非常喜欢的设计师 原研哉先生的书 《白》。『本书不讲颜色的。其实，我是在尝试探究一种叫做『白』的实体，用来找到由人们自身文化设定的那些感觉之源。换句话说，我试图找到那通过白的概念营造的简介和唯美的日本美学的源头。』这里摘录自这本书的前言。
说起原研哉，不得不提的一定会有MUJI（当然长野冬奥会纪念册也很出名，如果你想了解更多，可能我下次会推荐另一本《设计中的设计》的时候具体介绍原研哉），性冷淡风格一度成为主流。而这篇《白》更多的视图解释，这些极简主义，黑白灰，侘寂，这些性冷淡表象下面的源头。而这个源头的名字 叫做 『白』 ，亦或叫做『空』。&lt;/p&gt;

&lt;p&gt;当一个词语 被赋予了 颜色的意义的时候，你就会发现天然的 『它』（我是说表示颜色的这个词本身）就变成一种特别的存在，他们往往能够唤起我们的记忆。当然颜色是有纯粹的物理意义的，在我们的世界里他们是用 色度，明度， 和色值来组成三维环来表示所有颜色的。我们知道，无论哪种『媒介』都会使其传播的信息丢失，这里显然丢失了颜色包含一些信息，就像原研哉说的那样，一直被打破的鸡蛋的蛋黄的金黄色，或是茶杯里茶水的颜色，都不只是颜色。他们是带着物质本身固有属性的，他们会跟着味觉，质感。一起被看到的。所以，对颜色的理解，是与颜色，不至于颜色。颜色不应该只被在视觉维度被感受，这样感受颜色，就始终无法体会他们带来的所有体验。&lt;/p&gt;

&lt;p&gt;这样，毫无疑问的，颜色是一种语言，你能够感受到不同颜色的细微差别，情感驱使你辨别出更多的信息，被封印在物理媒介中的信息，被你解析出来了。这时候我就想起来Alfred North whitehead在1943年说过一句话 『艺术就是将一种模式强加于经历，以及识别这种模式所带来的审美享受』。这里可以插一句，最近我在学英语，和老师交流的时候，老师表示一些简单的单词连接到一起了就不知道意思了，我说：『可能文化环境是罪魁祸首吧。就像外国人肯定不能从韦编三绝这四个字中知道我在说一个人很勤奋一样。』，回到书上，这里的颜色也是一样的，他们的意义也是经过时间的长河，慢慢积累沉淀最后变成这样的。所以每一个颜色给你带来的冲击都是你处在的社会环境，民族文化带来的。&lt;/p&gt;

&lt;p&gt;然而。白，就是一个很有趣的颜色。我记得我在学水彩的时候，老师跟我说过，你不可以用白色来表示白色，白色是需要『空』出来的，这个手法在水彩中叫做留白。在构图的时候你就需要知道哪里不能沾染上颜色，其实对于超级新手的我来说，留白实在困难，因为白色实在太容易被入侵，浸染，被混合，你需要小心保护，细心再细心才可以。有时候一幅画就是因为一个留白而成为败笔。当时我也问过老师为什么不可以用太白粉的白来画这些空，老师说，他们不够透气，刻意，不自然。
白，很有意思，你可以混合所有颜色的光来得到白光。你也可以去掉所有的颜色，来获得白色。『一即全，全即一』。留白体现了空间距离也体现了『存在』（现在看来，也许钛白粉挑出来的白就不能表示『不存在』了吧）&lt;/p&gt;

&lt;p&gt;原研哉说白是混沌的反面。当所有颜色都在因为熵增，相互混合的时候。 
白，他表现出拒绝，拒绝所有颜色。却又能够接受所有颜色。
当他接受的时候他就变成了他接受的颜色。在他接受之前他就是白。
所以，白色是混沌的开始，而不是混沌的反面呀。我们没有办法触碰到白，因为只要我们接触到他，他就接纳了，变成了我们。我们无法观测到它，他会因为我们的观测改变。&lt;/p&gt;

&lt;p&gt;原研哉在对于创造和思考上有独特的见解。空带着思前行，『思考』这种行为模式萌生于『询问』的潜意识中，而『询问』又是基于『我思』。这也许是思考前放空自己的意义，放空自己是为了能想到更多。&lt;/p&gt;

&lt;p&gt;在构思这期节目的文案的时候，我就试图放空自己，在雨里暴走了10 公里。无论怎样的创造都需要很多很多的原始积累，使用原始积累才能让空带着你创造和思考。&lt;/p&gt;

</description>
          <pubDate>2016-10-31T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/essay/2016/10/31/%E7%99%BD-%E5%85%A8%E5%8D%B3%E4%B8%80-%E4%B8%80%E5%8D%B3%E5%85%A8.html</link>
          <guid isPermaLink="true">http://localhost:4000/essay/2016/10/31/%E7%99%BD-%E5%85%A8%E5%8D%B3%E4%B8%80-%E4%B8%80%E5%8D%B3%E5%85%A8.html</guid>
        </item>
      
    
      
        <item>
          <title>三亿巨奖从天而降，你的人生会何去何从</title>
          <description>&lt;blockquote&gt;

  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				《亿男》--『一男啊。那座塔啊...你不觉得从远处看才更美吗？』
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;关于金钱和幸福的答案，你想过吗？
金钱造就了对价关系 我们有意无意以此衡量价值
或许标价上的金额、折扣优惠斗大的数字、存折打印上的存款、帐单应付的总额，等于了生活；但，跌倒受伤后的拥抱、泪流满面后递上的温暖、轰隆雷雨后的大肆放晴，你怎么标价？
最究竟，金钱和幸福，并不是正比存在。
金钱或许创造了物质的幸福价值，但正如同本书提及，「一个人难以成就这种幸福，必须和别人在一起，才能感受到幸福的一刻」&lt;/p&gt;

&lt;p&gt;最近国庆假期，加上连续上班&lt;/p&gt;
&lt;h1 id=&quot;亿男我对金钱的思考&quot;&gt;亿男·我对金钱的思考&lt;/h1&gt;
&lt;p&gt;作为一个看眼缘的人，买这本书就只是因为他的配色很能抓住我。黄色的封面里，一个人面无表情的视图吞食着一张一张的货币，似乎这些在他看来就和普通的早餐没有什么区别。
我看书的时候很喜欢猜测作者会怎么写，尤其是在看小说的时候尤为严重，如果我猜测的剧情和作者写的得差不多，我可能会因为自己的小聪明窃喜，反之，就会感叹为何能从这样的角度如此看待问题。 &lt;a href=&quot;https://www.facebook.com/%E5%B7%9D%E6%9D%91%E5%85%83%E6%B0%97-567234320027537/&quot;&gt;川村元气&lt;/a&gt;给我一种和以前完全不一样的感受，诚然我猜对了下面的剧情发展，却又没有完全猜对（我猜对了开始却没有猜中结局）。&lt;/p&gt;

&lt;p&gt;这是一个贫苦社畜的变身暴发户的故事，因为贫穷饱受人生折磨，不仅如此他还承担下来弟弟的债务，于是他连给女儿买一个自行车都不行。
  钱，在一男的生命里慢慢的变成了唯一，因为缺钱的原因常常和妻子吵架导致自己和妻子女儿分居，为了能多赚钱他晚上还会去工厂做兼职，即使这样他依然不能摆脱贫穷。
  那一天，他从一位老妇人手里获得了一张可以兑换3亿圆的彩票。 从此命运就发生了改变，以前看似因为钱导致问题，现在看来似乎都可以解决（可是却都解决不了，但是现在的一男还没有发现）一男诚惶诚恐的搜索着那些一夜暴富的人的悲惨经历，他不希望自己也变成这样。于是，他找到了自己在大学的时候的挚友九十九，九十九是一个成功的互联网创业老板身价过亿，可是依然一副『穷人』的样子（这是我对九十九出场时候的描述）。一男在像九十九讲述自己的一系列遭遇之后，九十九让一男把钱全拿出来。他们潇洒挥霍了一晚上之后，第二天一男一个人醒来，发现九十九拿着他剩下的钱消失了。
  故事进行到这里，我想先岔开话题聊一聊别的。今天我在一个好久不用的包里最近才发现了去年平白无故丢失的压岁钱。但是，我转眼又把刚刚的红包弄丢了，把我平白无故多了300块钱弄不见了，我依然会不开心。这是为什么？既然这300块是平白无故多出来的，按道理来说少了对我来说应该没有影响可是为什么我会不开心？&lt;/p&gt;

&lt;p&gt;故事说到这里如果你和我有一样的看小说的习惯。那你一定在想这九十九真不像话人家这么信任你，你却如此对待一男。（如果你也是这么想的恭喜你进入了作者挖的第一个伏笔，ps：其实这本书的伏笔很多有机会再读一次再一一找出）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;『一男啊。那座塔啊…你不觉得从远处看才更美吗？』&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;九十九对一男这么说过，现在回头来看，可能那座塔指的是『有钱』这件事吧。九十九想让一男以旁观者的角度靠近那座塔，而不是拿着这3亿靠近它。&lt;/p&gt;

&lt;p&gt;后面的剧情是很典型的总分总的样子，一男分别拜访了九十九的伙伴们。见识到九十九的伙伴们对与突如其来的巨款的态度，和他们现在生活方式（我觉得这就是九十九安排的目的，让一男知道金钱在99眼里到底是什么）&lt;/p&gt;

&lt;p&gt;其中我印象最深的是两个女人的故事，一个是九十九的秘书十和子，一个是一男的妻子万佐子，在这两个女性角色中你能感受到女性的坚韧和脆弱，既能看到他们的铠甲又能看到他们的软肋。女生都是需要呵护的无论她看上去多厉害，多有钱，她仍然需要陪伴，需要爱。以前的十和子被金钱支配她只想要更多的钱和更好的男人，这样她的喜悲被这两者左右，如果不那么在乎这些，那是不是说明可以减少自己被『欲望』的制约呢？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;『万恶的根源并不是钱，而是对钱的爱。』——-塞缪尔·斯迈尔斯&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;幸福和金钱往往在很多人嘴里都会画上三个等号，真的是这样吗？
有几个有钱人这么说过？
你身边都是什么样的人描述这样的画面？&lt;/p&gt;

&lt;p&gt;故事似乎没有给一个对于幸福的答案。
支撑你一直生活的动力其实是『欲』。这个字可以有很多种翻译。
一男最后也找到自己的『欲』，为了和妻子女儿一起生活的欲望。
当然还有另外两个人的故事也很精彩，一定要看，看完之后和我分享吧。&lt;/p&gt;

&lt;p&gt;这里体现了两个矛盾，一方面我们不希望被可怕的『欲望』所支配，另一方面也不希望被贫穷所困扰。所以，为什么同样是欲望，一男最后为了和妻子三人一起生活就是『积极』的欲望，而一男以前为了让家庭变得更好『自私』的扛起了家庭。忽视别人的感受，这才是失败的原因吧。
  不知道我的你是不是一个有对象或者有喜欢对象的人，有的时候，为了另一半喜欢的东西努力往往比给自己买一个想要的东西更开心，可能，这就是作者想要表达的『积极的欲望』吧。&lt;/p&gt;

&lt;p&gt;记得我最喜欢的Up主 sinBasara 说过，所有事情走上了极端都是『邪教』，无论是绝望，还是希望。&lt;/p&gt;

</description>
          <pubDate>2016-10-15T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/onlybook/2016/10/15/%E4%B8%89%E4%BA%BF%E5%B7%A8%E5%A5%96%E4%BB%8E%E5%A4%A9%E8%80%8C%E9%99%8D-%E4%BD%A0%E7%9A%84%E4%BA%BA%E7%94%9F%E4%BC%9A%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E.html</link>
          <guid isPermaLink="true">http://localhost:4000/onlybook/2016/10/15/%E4%B8%89%E4%BA%BF%E5%B7%A8%E5%A5%96%E4%BB%8E%E5%A4%A9%E8%80%8C%E9%99%8D-%E4%BD%A0%E7%9A%84%E4%BA%BA%E7%94%9F%E4%BC%9A%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E.html</guid>
        </item>
      
    
      
        <item>
          <title>设计模式杂杂谈</title>
          <description>&lt;blockquote&gt;
  &lt;p&gt;北冥有鱼，其名为鲲。
鲲之大，不知其几千里也。
化而为鸟，其名 为鹏。鹏之背，不知其几千里也。
怒而飞，其翼若垂天之云。是鸟也 ，海运则将徙于南冥。
南冥者，天池也。 – 庄子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不知道从什么时候起设计模式，慢慢变成一个装逼必备的理论开始被讨论了，也许50年了。今天我们聊一种模式
##Strategy Pattern
我们先不说这些有的没的模式该是什么表现形式，照例应该先吹比。首先说说Strategy pattern的strategy是什么意思&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;a plan of action or policy designed to achieve a major or overall aim.
（以上是Google translate友情提供翻译。）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说Strategy是为了一个长期的目标制定的一个动作。从这种解释可以看出来，这个模式其实是代码中的动作（函数，方法）的集合。我想大家看过三国吧，Strategy pattern就像诸葛老儿给的锦囊计，你要用的时候找我,我给你我的技巧。（这里要注意的是，1.这个给的只是方法而不是对象（我说的这个对象是，即封装了属性又封装了方法的对象）。他在代码的表现形式上更像一个属性，你通过setter和getter方法改变和获取这个可设置的Strategy。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设计模式整体的概念在于抽象世界，所以他们常常把在&lt;strong&gt;不同情况&lt;/strong&gt;下改变的东西变得可以改变并且&lt;strong&gt;提出来&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;设计模式里面还有一个技巧，通过在类里实现一个空方法，调用组合对象的方法来提高并封装了组合对象的方法调用层级。让使用者认为自己在调用产生类的方法，而其实是产生类中组合实例的函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##🌰我来举个老师去上课的例子吧&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import Foundation
/// 这是锦囊类
protocol TeachCategorical {
    func teach()
}

class MathClass: TeachCategorical {
    func teach() {
        print(&quot;教数学&quot;)
    }
}

class EnglishClass: TeachCategorical {
    func teach() {
        print(&quot;教语文&quot;)
    }
}
/// ------------我是分割线 -----------
class ClassRoom  {
    private var teachFunction: TeachCategorical! = MathClass()
    
    func setTeachFunction(teach: TeachCategorical) {
        self.teachFunction = teach
    }
    
    func publish() {
        self.teachFunction.teach()
    }
}

class MathClassRoom: ClassRoom {
    override init() {
        super.init()
    }
    
    func teachMath() {
        self.setTeachFunction(MathClass())
    }
}

class EnglishClassRoom: ClassRoom {
    override init() {
        super.init()
    }
    
    func teachEnglish() {
        self.setTeachFunction(EnglishClass())
    }
}


let mathroom : MathClassRoom = MathClassRoom()
mathroom.teachMath()
mathroom.publish()

let englishRoom :EnglishClassRoom = EnglishClassRoom()
englishRoom.teachEnglish()
englishRoom.publish()
 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我把Strategy封装成接口（ps把需要抽象的方法做成接口，是个非常明智的选择，这恰恰也是接口存在的意义）然后写了两个不同的锦囊类。分别实现了teach方法用来教课。&lt;/p&gt;

&lt;p&gt;下面就是需要把不同的教室分配为不同的职能了。于是，应该发生的样子应该是数学教师用来教数学，英文教室教英文。&lt;/p&gt;

&lt;p&gt;把教室抽象出来并且给教室一个『锦囊』属性让教室在想设置这个教室职能的时候可以设置。（当然这种设置可以放在任何初始化内部对象的地方比如init方法，set方法之类的）。
教室还有一个职能就是让这个『锦囊』有用（也就是调用这个实例的方法）&lt;/p&gt;

&lt;p&gt;这里很好的看到了，我把整个程序分割成两个部分。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;锦囊&lt;/li&gt;
  &lt;li&gt;手持锦囊的一群东西&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就是Strategy模式。
记住的是，你在编码的时候发现什么被经常改动。如果改动的是方法，记得使用接口封装他们。如果改动的是数据结构，我们下次再说用什么。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;##同胞兄弟 Factory Pattern&lt;/p&gt;
&lt;h3 id=&quot;defalut-factory-pattern&quot;&gt;defalut factory pattern&lt;/h3&gt;
&lt;p&gt;为什么要在一起说这两个pattern呢，因为我觉得从结构上来看他们很像，可以一起&lt;strong&gt;横向对比&lt;/strong&gt;。
照例我们还是先从名字入手，factory，没啥好介绍的。名词:工厂。也就是说，我们可以通过这个『工厂』来『制造』并且产出『产品』，这里的『产品』就是我们想要批量生产或者方便添加的类。
有上述可以得到，我们在这个模式中需要定义产品对象。自然而然的，我们需要定义接口来指导行为。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 简单工厂模式样例
/* ------- */
/// 这是产品类
protocol Operators {
    func perform()
}

class Addition: Operators {
    func perform() {
        print(&quot;做加法&quot;)
    }
}

class Minies: Operators {
    func perform() {
        print(&quot;做减法&quot;)
    }
}

class Divice: Operators {
    func perform() {
        print(&quot;做除法&quot;)
    }
}

class Mutiple: Operators {
    func perform() {
        print(&quot;做乘法&quot;)
    }
}

enum operatorsEnum {
    case Add, Minie, Divice, Mutiple
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;由此可见，这个产品的模板其实和策略模式的策略类的表现形式如出一辙。继续看工厂类的实现&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class OperatorsFactory {
    func createOperatorWithType(operat: operatorsEnum) -&amp;gt; Operators {
        var operators : Operators
        switch operat{
        case .Add :
            operators = Addition()
        case .Divice:
            operators = Divice()
        case .Minie:
            operators = Minies()
        case .Mutiple:
            operators = Mutiple()
        }
        return operators
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;作为简单工厂，只需要一个函数来产生不同的产品，通过接口来使用『里氏替换原则』接受所有的产品类型，返回产品实例。
最后看一下使用方法。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class User {
    var factory: OperatorsFactory
    init(operaFactory: OperatorsFactory) {
        self.factory = operaFactory
    }
    
    func perfromWithType(opType: operatorsEnum) {
        let weapon: Operators = factory.createOperatorWithType(opType)
        weapon.perform()
    }
}

let users = User(operaFactory: OperatorsFactory())
users.perfromWithType(.Add)
users.perfromWithType(.Minie)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;首先使用者类中，存在一个组合的工厂类的实例（这样一点又和策略模式的角色类的实现相同），然后有一个方法（createOperatorWithType :opType）通过外部的产品类型返回实例，直接调用这个实例的方法（以转换为用户类的方法）&lt;/p&gt;
&lt;h3 id=&quot;factory-method-pattern&quot;&gt;Factory Method Pattern&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;变量就是类，类和变量的相互转化&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;老生常谈了，我们还是从名字开始入手，『工厂方法』这名字可能说明不了什么问题（比较像中国人起的名字）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫&lt;strong&gt;虚拟构造器&lt;/strong&gt;(Virtual Constructor)模式或者&lt;strong&gt;多态工厂&lt;/strong&gt;(Polymorphic Factory)模式，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Virtual Constructor Pattern和Polymorphic Factory Pattern这两个名字就很能说明问题了。
在计算机科学里面常常有人喜欢说Virtual这个词，『虚拟化』听上去就很牛逼，基本上看到这个词的时候就知道这个人是把什么东西抽象成一个抽象描述了，而在代码实现中接口就是这种抽象描述。再看看Polymorphic Factory就能知道这个『工厂』可能是很多的。（一般这种很多的东西，就是通过不同的类来分割职能，所以需要使用接口把他们统一起来）&lt;/p&gt;

&lt;p&gt;来我们使用Virtual constructor 重构上面的简单工厂看看。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class OperationDecorator: Operators {
    var operat: Operators! = nil
    init(opera: Operators) {
        self.operat = opera
    }
    func perform() -&amp;gt; String{
        return operat.perform()
    }
}

class DoubleDecorator: OperationDecorator {
    override func perform() -&amp;gt; String{
        return &quot;浮点数&quot; + self.operat.perform()
    }
}

class IntDecorator: OperationDecorator {
    override func perform() -&amp;gt; String {
        return &quot;整数&quot; + self.operat.perform()
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里写了两个产品，&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol OperationUser {
    func performfWithType(operationType: operatorsEnum)
    func createOperaWithType(operationType: operatorsEnum) -&amp;gt; Operators!
}

extension OperationUser {
    func performfWithType(operationType: operatorsEnum) {
        let opt: Operators! = createOperaWithType(operationType)
        print(opt.perform())
    }
}

class DoubleUser: OperationUser {
    func createOperaWithType(operationType: operatorsEnum) -&amp;gt; Operators! {
        var opt: Operators
        switch operationType {
        case .Add:
            opt = DoubleDecorator(opera: Addition())
        case .Divice:
            opt = DoubleDecorator(opera:  Divice())
        case .Minie:
            opt = DoubleDecorator(opera:  Minies())
        case .Mutiple:
            opt = DoubleDecorator(opera:  Mutiple())
        }
        return opt
    }
}

var user: OperationUser = DoubleUser()

user.performfWithType(.Add)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;###Abstract Factory Pattern
抽象工厂模式的主要作用就是把上述的工厂类的方法抽象成接口。我们直接看代码。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol WeaponType {
    func fire() -&amp;gt; String
}

class AK: WeaponType {
    func fire() -&amp;gt; String {
        return &quot;AK: Fire&quot;
    }
}

class AWP: WeaponType {
    func fire() -&amp;gt; String {
        return &quot;AWP: Fire&quot;
    }
}

class HK: WeaponType {
    func fire() -&amp;gt; String {
        return &quot;HK: Fire&quot;
    }
}

class WeaponDecorator: WeaponType {
    var weapon: WeaponType! = nil
    init(weapon: WeaponType) {
        self.weapon = weapon
    }
    
    func fire() -&amp;gt; String {
        return weapon.fire()
    }
}

class GermanyDecorator: WeaponDecorator {
    override func fire() -&amp;gt; String {
        return &quot;德国制造&quot; + self.weapon.fire()
    }
}


class AmericaDecorator: WeaponDecorator {
    override func fire() -&amp;gt; String {
        return &quot;美国制造&quot; + self.weapon.fire()
    }
}

/**
 *  抽象工厂接口
 */
protocol WeaponFactoryType {
    func createAK() -&amp;gt; WeaponType
    func createAWP() -&amp;gt; WeaponType
    func createHK() -&amp;gt; WeaponType
}

/// 抽象工厂的具体类实现

class AmericanWeaponFactory: WeaponFactoryType {
    func createAK() -&amp;gt; WeaponType {
        return AmericaDecorator(weapon: AK())
    }
    
    func createHK() -&amp;gt; WeaponType {
        return AmericaDecorator(weapon: HK())
    }
    
    func createAWP() -&amp;gt; WeaponType {
        return AmericaDecorator(weapon: AWP())
    }
}

class GermanyWeaponFactory: WeaponFactoryType {
    func createAWP() -&amp;gt; WeaponType {
        return GermanyDecorator(weapon: AWP())
    }
    
    func createHK() -&amp;gt; WeaponType {
        return GermanyDecorator(weapon: HK())
    }
    
    func createAK() -&amp;gt; WeaponType {
        return GermanyDecorator(weapon: AK())
    }
}

enum WeaponTypeEnumeration {
    case AK, AWP, HK
}

class WeaponUser {
    private var factory: WeaponFactoryType
    init(factory: WeaponFactoryType) {
        self.factory = factory
    }
    
    func setFactory(factory: WeaponFactoryType) {
        self.factory = factory
    }
    
    func fireWithType(weaponType: WeaponTypeEnumeration) {
        var weapon: WeaponType
        switch weaponType {
        case .AK:
            weapon = self.factory.createAK()
        case .AWP:
            weapon = self.factory.createAWP()
        case .HK:
            weapon = self.factory.createHK()
        }
        
        print(weapon.fire())
    }
}


var user: WeaponUser = WeaponUser(factory: AmericanWeaponFactory())

user.fireWithType(.AWP)
user.fireWithType(.HK)

user.setFactory(GermanyWeaponFactory())
print(&quot;\n&quot;)
user.fireWithType(.AWP)
user.fireWithType(.HK)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上述代码和工厂方法模式对于user的封装基本相同，都是组合一个工厂，只是这次的是一个抽象的接口，上次是类。&lt;/p&gt;
&lt;h3 id=&quot;工厂方法和抽象工厂模式的异同&quot;&gt;工厂方法和抽象工厂模式的异同&lt;/h3&gt;
&lt;p&gt;其实抽象工厂是通过接口来产生工厂的集合，而工厂方法会选取工厂来『生产』&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 *  对使用者抽象
 */
protocol WeaponUserType {
    func fireWithType(weaponType: WeaponTypeEnumeration)
    func createWeaponWithType(weaponType: WeaponTypeEnumeration) -&amp;gt; WeaponType!
    func createWeaponFactory() -&amp;gt; WeaponFactoryType
}

extension WeaponUserType {
    func fireWithType(weaponType: WeaponTypeEnumeration) {
        let weapon: WeaponType = createWeaponWithType(weaponType)
        print(weapon.fire())
    }
    
    func createWeaponWithType(weaponType: WeaponTypeEnumeration) -&amp;gt; WeaponType! {
        var weapon: WeaponType
        
        switch weaponType {
        case .AK:
            weapon = createWeaponFactory().createAK()
        case .AWP:
            weapon = createWeaponFactory().createAWP()
        case .HK:
            weapon = createWeaponFactory().createHK()
        }
        
        return weapon
    }
}

class AmericanWeaponUser: WeaponUserType {
    func createWeaponFactory() -&amp;gt; WeaponFactoryType {
        return AmericanWeaponFactory()
    }
}

class GermanyWeaponUser: WeaponUserType {
    func createWeaponFactory() -&amp;gt; WeaponFactoryType {
        return GermanyWeaponFactory()
    }
}

var usr: WeaponUserType = AmericanWeaponUser()
usr.fireWithType(.AK)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在这里工厂方法模式的具体实现就是User接口实现类的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func createWeaponFactory() -&amp;gt; WeaponFactoryType&lt;/code&gt;方法。通过不同类对于这个方法的实现，实现工厂的选取，选取工厂是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var usr: WeaponUserType = AmericanWeaponUser()&lt;/code&gt;产生的。&lt;/p&gt;

&lt;p&gt;参考链接
&lt;a href=&quot;http://so.gushiwen.org/guwen/bookv_3254.aspx&quot;&gt;逍遥游&lt;/a&gt;
&lt;a href=&quot;http://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/strategy.html&quot;&gt;策略模式&lt;/a&gt;
&lt;a href=&quot;http://www.cnblogs.com/ludashi/p/5302269.html&quot;&gt;参考博客Swift实现&lt;/a&gt;&lt;/p&gt;

</description>
          <pubDate>2016-05-26T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/2016/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%82%E6%9D%82%E8%B0%88.html</link>
          <guid isPermaLink="true">http://localhost:4000/2016/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%82%E6%9D%82%E8%B0%88.html</guid>
        </item>
      
    
      
        <item>
          <title>Rework · 重来</title>
          <description>&lt;p&gt;####更为简单有效的商业思维
     决定买这个本书也是因为大约4年前在酷壳上看到耗子叔写过一篇读书笔记，那时候刚高中毕业根本不懂这本再说些什么。如今4年过去了大概不一起要更有感受了吧。
     这本书的的作者是大名鼎鼎的&lt;a href=&quot;https://twitter.com/jasonfried?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor&quot;&gt;Jason Fried&lt;/a&gt; 和&lt;a href=&quot;https://twitter.com/dhh?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor&quot;&gt;David Heinemeier Hansson&lt;/a&gt;大卫和贾森以前创立了&lt;a href=&quot;https://37signals.com/&quot;&gt;37signals&lt;/a&gt;。这本书的行文很像伊索寓言，用各自独立成片的场景和你可能出现的问题为线索从头到尾教你如何重来。
     作为一个一直在谋划自己的app的新鲜人，进阶片中用很多东西值得我去学习的。就比如&lt;/p&gt;

&lt;p&gt;####与其做个半成品，不如做好半个产品&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;与其做个半成品，不如做好半个产品。
拿起斧头动手砍吧。为了下一个伟大的起点，让我们把那些还不错的枝节给砍掉吧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;作为一个自己产品的产品经理我更希望的是我的产品能够有更多更喜欢的feature来满足我和用户的需求，于是功能越来越多导致根本不能做完一个完成度很高的产品，看了这篇之后我也尝试着把不重要的功能退后，慢慢先做出一个baby app出来让后让她成长。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;####关注不变量&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Focus on what wont change
你的事业核心应该建立在不变的基础之上。应该投资那些人们现在需要10年后也需要的东西上面
要记住，时尚会凋零（至少是有周期的）只有当你聚焦于长久功能的时候，你才会发现自己把握住永不凋落的东西。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  我还记得我们大学的食堂里面有一个大横幅，上面写着这世间万物唯一不变的就是变化。我自己对于这段的解读可能要结合我在计算机领域学习的知识树选择，我很谨慎的选着过去20年到现在还仍然没有消亡的技术学习，辅以新鲜的热门领域。这样构建自己的知识树之后就会发现，很多热门的东西再循环的出现，比如过去使用在游戏领域的图像刷新技术现在用在了web2.0的页面上。比如很久之前的Functional Programming 现在因为并行运算又活了（并行的效率的事情我们可以下次再说，这次不展开书）。Devid站在一个公司的基础上教导我们公司需要把不变的东西把握住之后再慢慢吸收那些演变后的新技术。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;####音乐就在你的指尖流淌 
&lt;strong&gt;练习，练习…..&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;… ……人们把装备当做取胜的法宝，却不愿意花时间去练习，于是一直泡在专业器材店里。他们想要寻找捷径，然而，最好的工具不是用在普通领域的，而且你在起步阶段肯定用不到它。
…….. … 就用你现在手头有的或者能负担的起的，然后开始做吧。工具不重要，就用下奶工具也可以一样棒，音乐就在你的指尖流淌。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;    这段真是醍醐灌顶，无论我在学什么东西的时候，好像我越在乎我用的是什么的时候越干的不好，无论是画画，代码，摄影或者是别的。也许好的设备好的机器可以提高你的出品，但是不能增长你的技能，技能是通过练习和熟练沉淀出来的，好的设备只能虚高你的结果。你根本不是你看到的样子。
####不要过早关注细节&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;…. 。..当开始设计规划的时候，我们会用大号粗体的白板笔，而不是圆珠笔，把大致想法描绘出来。为什么呢？圆珠笔太完美了，分辨率太高了，会让你不自觉的关注那些还不需要关注的东西。结果让你把注意力放在了次要的东西上面。
你在起步阶段只需要操心纵观全局。
&lt;a href=&quot;https://en.wikipedia.org/wiki/Walt_Stanchfield&quot;&gt;Walt Stanchfield &lt;/a&gt;作为迪斯尼工作室的著名画师，曾经鼓励他的手下的漫画师要在一开始『忘掉细节』。理由是：在初期，关注细节不会给你带来任何好处。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;   这一段真的是深有感触，我相信自己做过项目的人肯定了解这样的感受，在项目开始之初，有很多想法想要实现，一个简简单单的登录功能也想做的尽善尽美。到最后除了登录注册之外没有一个功能能够拿出来的。
   我在这里举出的🌰都是关注基础，关注技能，关注框架。只要方向没有错，我们就能够在这样的骨架上加上肌肉，皮肤。这样才是一个简单的途径。
   
####最后——–灵感是稍纵即逝&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果你的灵感是在周五驾临的，那就放弃周末，直奔主题。当你为了这个灵感亢奋的时候，就能在24小时之内做完两个星期的工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;   简单的说，如果你想做一件事，就去做吧。
##总结
   这本书还说了一些公司管理层面的东西，可能不久的将来我会用到吧，现在就不一一整理了。
以后可能会出一个续篇来说说这篇文章没有说的部分。&lt;/p&gt;

</description>
          <pubDate>2016-01-30T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/onlybook/2016/01/30/Rework-%E9%87%8D%E6%9D%A5.html</link>
          <guid isPermaLink="true">http://localhost:4000/onlybook/2016/01/30/Rework-%E9%87%8D%E6%9D%A5.html</guid>
        </item>
      
    
      
        <item>
          <title>行者</title>
          <description>&lt;p&gt;今天我听了一个曾经环中国一周骑行的大叔的吹水会。
大叔姓许叫许金良。我一般很难认识第一次就能记住别人的名字，今天绝对是第一次。
先说说大叔吧，超过180的大高个，典型的北方人的国字脸，眼神和蔼但是充满经历。大叔给的PPT的题目叫“你我，皆行者”，下面小小的写了一行字 “行走在时光之上，寻找生命中最美丽的一天！”。
开头，大叔问了一个问题，“你认为旅行的意义是什么。”
我在当时没有举手说，现在在这里我补一下吧（这是不是就是我怎么也迈不出行者第一步的原因呢）
我觉得旅行对我来说，应该是跟贴近生活的，我的旅行应该是看看别的地方的人是怎么样过日子的，而不是像现在这里的一些人一样，为了自己觉得能征服什么而去旅行，旅行也许就像刚刚开始的那段话里面说的一样，其实它一直都在，即使你每天3点一线一沉不变也是在旅行，你在你的人生路上漫漫之旅呢。所以旅行对我的意义还是为了开拓视野。
（笑）也不知道这样的话，在当时说是怎么样的一种样子呢。
当时，大叔提出这个问题的时候，上来一个胖子。他自称是我们学校骑行社的一员。眉飞色舞的聊着自己如何走滇藏线，和穿越塔克拉玛干的事迹。用姜老师的话就是面部表情非常丰富，我至少看到了4种心情，骄傲，挑衅，得意，大叔和蔼的在旁边看着。记得当讲到大叔自己穿越塔克拉玛干的时候他只是提了一下这里是刚那个胖子说的地方，就没有说什么了。（其实那时候我就想，有些人走了这么长的路，最后回来了，也就只是走路而已，可是有些人走的是一条灵魂升华的路）
	我记得大叔说过一句很好的话，他说，为什么走着么长的路你不是坐飞机， 坐火车，或者坐车，而是选择骑摩托，骑自行车呢。大叔说，骑车去旅行其实是一个让你慢慢剥离自己的漫长的过程，你会在这个漫漫旅途中慢慢的剥离你自己，把你想要的分离出来。我现在想想也许，这就是过去苦行的人们所获得的吧。也许，这样的长途之旅就是现在的苦行呢。
	今天下午短短1.5h的活动，我曾有两次落泪。第一次，是大叔说，他们在新疆还是西藏的时候有一座山上的公路上有个坟头它是一个北大的女生的，她因为高原反应死在了这里，于是她就被葬在这荒漠和蓝天之间了。听说附近的人们都说她变成了这里的山神保佑着路过这里的每一个行者。
	我听到这里，其实我以前也又听说过有的行者因为一些事情在路上就去世了，我不太能表述我的想法，我就想说，你们真棒。
	第二次落泪是在看到大叔说有一个在山脚下生活的大妈对她像亲生儿子一样的时候。他说大妈是基督徒，大妈很好，我知道他即使没有说什么我已经能从他的表情和流露出来的情感里面听出来，真的大妈真好，能对一个陌生的人。
好，小小的记一下今天我参加这个活动而已。
最后附上大叔说的话
我们都是践行者！
无意说服别人，也无意改变世界，只是偏执的走在路上，希望在细微处影响别人。
大叔来我敬你一杯。
niclas
2014.3.19&lt;/p&gt;

</description>
          <pubDate>2014-05-19T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/essay/2014/05/19/%E8%A1%8C%E8%80%85.html</link>
          <guid isPermaLink="true">http://localhost:4000/essay/2014/05/19/%E8%A1%8C%E8%80%85.html</guid>
        </item>
      
    
      
        <item>
          <title>La bibliotheaque</title>
          <description>&lt;p&gt;很久很久了，我没有一个安静缓慢的下午了，最近的时间都在图书馆里面度过了，每当这个时候（午饭过后）图书馆里面的人最少，自习的座位上面淅淅沥沥零零散散的坐着一些人，有点扶着额似乎在考虑这什么，有的人趁着这个安静的时候小憩一会儿听听歌，当然也有人像我一样，东张西望的看着周围的人在干什么。
总之，图书馆以前在我心目中的样子一直是一群爱学习的人争分夺秒的战场，是他们与学习拔河的沙场。因为从小你就被灌输说，要多去图书馆看书知道吗？这一类的话，其实，看书在我从小的记忆里就是和痛苦100%挂钩的。也就说图书馆就是我的痛苦之源，
我问过一些喜欢去图书馆的朋友们，问他们去图书馆都干些什么。
回答都千奇百怪，有些可能你都无法接受。
有陪女朋友的，有看电影的，有为了来上网的（图书馆有公共电子阅览室），还有的只是为了准备某场考试，考试结束了就不会再来这个伤心地了。
其实大部分人都是这么想的，我不考试来图书馆干嘛，这里完全不是属于我的style呀，全是一些书呆子，上了4年学什么都没学会到头来还要准备考研来蒙混过关。
在我看来，整个学校里面能够慢慢生活的地方就是图书馆了，悠闲的下午，找一个靠窗的位子坐上一下午。晒晒太阳，吹吹暖暖的风，听着电脑里面的歌。
思绪飘零，其实根本不需要蔬食我也能遨游。
一杯水，一台电脑。累了就靠着，你不会因为栏杆上有一层浮灰就会讨厌它的，反而在多年之后你会因为这层没有擦去得浮灰想起什么。
也许是想起了那个悠闲的下午，也许是想起了你左手边那个想考公务员的同学的大水壶。呵，就算你都忘了也没有关系。
珍惜，
珍惜你能再图书馆的时光吧。即使无趣，也能落得清闲。
niclas
2014-3-17&lt;/p&gt;

</description>
          <pubDate>2014-05-17T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/essay/2014/05/17/Labibliotheque.html</link>
          <guid isPermaLink="true">http://localhost:4000/essay/2014/05/17/Labibliotheque.html</guid>
        </item>
      
    
      
        <item>
          <title>同好</title>
          <description>&lt;p&gt;什么是同好呢，就是一群有相同爱好的人。
人是一个很奇怪的生物，这种生物呢，他是一个社会性非常强的生物，可是他们之中总是想有一些人希望自己是独一无二的，于是，他们开始在爱好上让自己与别人区别开来。可是他们又不能逃脱出自己是社会动物的本质于是又希望找到一些和自己有相同爱好的人组成一个一个小团体以满足自己的对社会和独立个性的需呀。
爱好这种东西真的很大很多。比如我吧，我只有在自己不开心或者状态不好的时候才会写东西，平时我可是都是以程序员自居的（笑）。
有些爱好因为太冷僻所以被别人叫做癖好。
作为中国人当然看到病字头的东西就有一种从内而外的厌恶感，癖好，很不幸的被归为了这一类。所谓癖好其实也是爱好的一种，我到是觉得，爱好也不应该分什么贵贱为什么有些爱好就要被歧视被说成是癖好？有些爱好你就可以说这是事业呢。
其实，总归都是大多数人控制着这种言论走向，所以，才会有人为了我上一段说的社会性抛弃了自己的爱好，去迎合别人的爱好。可是爱好别人的爱好，还是自己的爱好吗？
显然。肯定不是了，爱好这种东西如果也需要和别人一样的话那你活的也太被动了。
诚然，有些人会苦着脸说，我这是为了生活，为了活下去我必须这样。这样大义凛然的说的时候也许背影里你还能看到他发出的光。为了生活你就可以抛弃你爱的东西？呵。
找理由这种把戏我从孩提时代打破家里的花瓶的时候就会了。&lt;/p&gt;

</description>
          <pubDate>2014-04-16T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/essay/2014/04/16/%E5%90%8C%E5%A5%BD.html</link>
          <guid isPermaLink="true">http://localhost:4000/essay/2014/04/16/%E5%90%8C%E5%A5%BD.html</guid>
        </item>
      
    
      
        <item>
          <title>源，缘，圆  从圆聊到爱看杂记</title>
          <description>&lt;p&gt;也许，我自己想的题目是这个缘，可是打出来的竟是这个源。现在想想，也许缘和源没有什么区别。
小时候，再解释一个字的意思的时候老师都是叫我们组词，通过词组来理解单字的意思。
缘，姻缘，缘分。源有，源头；溯源。
我为什么说这两个字有相同的意思呢。万物皆由源生，由缘起，随缘灭。
也许你看见了我还写了一个字，圆。在数学里。圆被看做是完美的存在，在物理中圆是所有理想模型的基础，在佛家，世间因果都是圆。
圆代表了轮回，很久之前，西方的炼金术中就运用了衔尾蛇的图案来表示循环，想必大家也看过这样的图，大地在一个乌龟的背上，整个图被衔尾蛇所包围。
说着说着，我都忘记了，自己开这个OmmWriter是为什么了。
我不知道为什么你明明可以把我拉黑不理我让我死心，却不这么做，而是跟我说你还是可以骚扰我，这样的话呢。
你是因为你的博爱？
还是什么。
如果这篇文章又被我传到网上，被发小看见肯定又要被讥笑说自己矫情。
对了，我原来是想说把题目换成矫情来着的，后来还是矫情的把矫情换掉了，以掩盖我的矫情。
呵呵。
我快不知道这个呵呵的意思了，太多心怀恶意的人使用过的词之后，整个词都会变得恶意满满，也就是说其实恶意是可以被保存，并且被传播的，传播的速度根据网速来定。
我记得我跟谁说起过，我喜欢看杂记，原因自己也不知道。
现在回想看看，我大概知道是为什么了。因为，杂记一般都是说作者本身的事情的，没有什么很多的伏笔描述，有的可能是一点点感悟，一点点人生阅历的记述。就像村上桑说的一样，小说家都是骗子，他们说谎，用自己在脑子里面架构的世界观来描述事物。当然，我有的时候也喜欢看，可是比起小说，我更喜欢看杂记，我可以先看看标题，看看哪个标题更吸引我，我就先看哪一个，然而小说就不能给我这种乐趣（呵呵，也许不是所有人都觉得这叫乐趣）。
niclas
2014-03-20&lt;/p&gt;

</description>
          <pubDate>2014-03-20T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/essay/2014/03/20/%E4%BB%8E%E5%9C%86%E8%81%8A%E5%88%B0%E7%88%B1%E7%9C%8B%E6%9D%82%E8%AE%B0.html</link>
          <guid isPermaLink="true">http://localhost:4000/essay/2014/03/20/%E4%BB%8E%E5%9C%86%E8%81%8A%E5%88%B0%E7%88%B1%E7%9C%8B%E6%9D%82%E8%AE%B0.html</guid>
        </item>
      
    
      
        <item>
          <title>shine</title>
          <description>&lt;p&gt;今天我早早的来到图书馆，霸占了一个在下午能晒到太阳的位置，好吧，我能够晒到的就只是下午3~4点钟的太阳。
一般这个时候的太阳已经不是这么毒辣了，再加上现在才是苏中地区的初春，其实如果没有穿外套的话会有点冷。
好几天了，我好像已经好久没有开始我的正式工作的意思，一直在默默的改变这自己的生活方式，我企图拖慢自己的节奏，我不想就这样莫名的被一些莫名的考试考证占据着我宝贵而得之不易的时光，
不知不觉，我打成自己的目的已经1年了。
一个学期已经默默的过去了。我的大学生涯可能跟大多数人都不一样，从大三我又重获新生得到了不能说是自己想要的生活。只能说自己圆了自己在别人面前吹过的牛，
我现在也能淡定沉稳的对别人说，当年我怎么怎么样了。
以获得一些无谓的自豪感(这不算是病态吧，笑)
我每次写文章起名字都是很随便的，想到什么就写什么。聊天工具里面有一个朋友名字叫yourSunshine突然想到，其实这里的shine也许是杀人的激光也说不定呢。
今天完成了，这学期选修课的任务没有多难，反倒说还很简单，可能是我在不悦的状态下所以工作效率变高的原因吧，
明天开始自己的事情吧，我记得有人说过，人啊，其实就是一直做自己的主角，一直做别人的配角的存在。
无论你是谁在别人那里只是整篇故事里面的一章，也许你运气不好，最多也就是一个插画哈。
不必太认真，认真就输了。
可我又没跟谁比呀。
niclas 
2014-03-18&lt;/p&gt;

</description>
          <pubDate>2014-03-18T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/essay/2014/03/18/shine.html</link>
          <guid isPermaLink="true">http://localhost:4000/essay/2014/03/18/shine.html</guid>
        </item>
      
    
      
        <item>
          <title>忘</title>
          <description>&lt;p&gt;这几天过的还不错，充实。
有人说过，你可以像猪一样懒，但是你没办法像猪一样懒得心安理得。
可能因为自己把自己压的太充实了，所以有些事情转脸就忘了，也许是因为自己还在逃避，不肯面对所以才会发生这样的反应，因为靠近了就像跑，想躲，想离开，所以靠近了就只能跑只能躲，只能离开。
所以忘记了自己之前说的话，我最近一直在给自己找理由，找到的都是一些无关痛痒，语无伦次的荒诞的理由，老是把自己放在弱者的地方想问题，却又要表现出自己谁也欺负不了的架势。
我都快忘了，我是谁了。
和别人一样，工作已经成了我的麻醉剂，就像关节疼痛只能打封闭治疗一样，你只能希望它的持续时间变得很长，很长。可是，和一般的止痛剂治疗一样，工作也是有自己的持续时间的。
而我，就有点像病入膏肓的瘾君子。在它失效前就想着怎样才能获得下一次治疗以满足我对孤独的渴望，
其实，与其说我是对孤独渴望，不如说其实我更渴望你。我不想任何人因为同情而对我有任何恻隐之心。
这样对我来说，已经无法用是否尊重来定义了。
所以，我宁可没有也不想这样。
也许，这个题目应该叫宁缺毋滥，呵呵。
其实我不太能看的起那些说自己是宁缺毋滥的人，这些拿着自认为高尚的理由，在单身汉中获得优越感，其实还不是找不到吗。
大家都一样，什么宁缺毋滥。呸
呵。
好像越来越偏离主题了啊，最近我看上去被工作压的都不能喘息了，其实都是我自己自找的，我想尽办法找东西做，不管有用没有用，根据经验这样我会变得不那么伤心。
其实，我还是第一次有妹子三番五次问我喜不喜欢她。对呀，我就是喜欢了，但是我不觉得我能给你幸福。所以我选择对她矢口否认。
我怎么会喜欢你，你看看你长成这样，又笨，又呆。
	我很高兴你没有看出来我这句话说得是假话，因为你就是这么单纯，善良。虽然经历过很多但是依然这么阳光，其实我说的都是你的优点呀。好了，我知道你肯定会认真对待这份感情的。
mine sunsine.bless you.
niclas  2014-3-16&lt;/p&gt;

</description>
          <pubDate>2014-03-16T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/essay/2014/03/16/%E5%BF%98.html</link>
          <guid isPermaLink="true">http://localhost:4000/essay/2014/03/16/%E5%BF%98.html</guid>
        </item>
      
    
      
        <item>
          <title>在OSX10.9（小牛）自己编译支持Python的vim7.4源码之路</title>
          <description>&lt;h2 id=&quot;事情的起因&quot;&gt;事情的起因&lt;/h2&gt;

&lt;p&gt;要说事情的起因的话其实是我在10.8升级到10.9之后VIM总是有些不听使唤，不过那时候没有怎么写代码于是就凑活着用了。只到昨天晚上snipMate突然不能用了于是我卸载之后再装回来结果VIM彻底不停使唤了，于是我就想说里外里把VIM重新装一遍正好体验一下新特性.&lt;/p&gt;

&lt;h2 id=&quot;每次编译vim都是坎坷的&quot;&gt;每次编译VIM都是坎坷的&lt;/h2&gt;
&lt;p&gt;编译VIM肯定需要源代码，所以编译前需要的准备工作就是要在官网上或者google code（如果你能下的下来的话）上下载一份最新的代码:&lt;br /&gt;
&lt;code&gt;hg clone https://vim.googlecode.com/hg/ vim&lt;/code&gt;
然后使用./configure增加自己想要的配置具体我不多说了。&lt;a href=&quot;http://benfrain.com/compiling-custom-vim-source-os-x-10-9-mavericks/&quot;&gt;点我了解跟多&lt;/a&gt;&lt;br /&gt;
前面的步骤我都轻车熟路,在make的时候出现了如下的编译错误&lt;br /&gt;
&lt;code&gt;
os_unix.c:830:13: error: conflicting types for &apos;sigaltstack&apos;
        extern int sigaltstack __ARGS((const struct sigaltstack *ss, str...
                   ^
/usr/include/signal.h:85:5: note: previous declaration is here
int     sigaltstack(const stack_t * __restrict, stack_t * __restrict)  _...
        ^
&lt;/code&gt;
仔细看一下好像是什么数据结构冲突的样子，知觉上不像是我的编译环境的问题，于是我在某度上搜了一下发现在OSX上编译VIM的少之又少实在找不到有什么又用的资料于是跑到谷歌的怀抱在
&lt;strong&gt;vim develop list&lt;/strong&gt;&lt;a href=&quot;http://permalink.gmane.org/gmane.editors.vim.devel/43168&quot;&gt;上面&lt;/a&gt;找到,相关问题的解决patch 有此问题的同学可以自己打一下补丁就可以了。
不会用&lt;a href=&quot;https://www.drupal.org/node/60108&quot;&gt;patch&lt;/a&gt;的同学点击链接这里有教学。&lt;/p&gt;

&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;每次只要和vim相关的配置操作就要花费很多时间去解决，这里记录一下希望有后来人不要走弯路，基本上有问题找vim GitHub上面的issue 也可找vim develop list 也可以，别用没有用的Baidu了真的。&lt;/p&gt;

&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/cn/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; style=&quot;border-width:0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/3.0/cn/80x15.png&quot; /&gt;&lt;/a&gt;&lt;br /&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/cn/&quot;&gt;知识共享署名-非商业性使用-禁止演绎 3.0 中国大陆许可协议&lt;/a&gt;进行许可。
&lt;strong&gt;本文章遵循CC协议，请自觉遵守    -作者Niclas&lt;/strong&gt;
下午3:59 2014年10月10日
&lt;br /&gt;niclas&lt;/p&gt;

</description>
          <pubDate>2014-02-23T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/2014/02/23/%E5%9C%A8OSX10.9%E8%87%AA%E5%B7%B1%E7%BC%96%E8%AF%91vim7.4%E6%BA%90%E7%A0%81.html</link>
          <guid isPermaLink="true">http://localhost:4000/2014/02/23/%E5%9C%A8OSX10.9%E8%87%AA%E5%B7%B1%E7%BC%96%E8%AF%91vim7.4%E6%BA%90%E7%A0%81.html</guid>
        </item>
      
    
      
        <item>
          <title>总结OSX上面配置VIM + slimv的common Lisp环境</title>
          <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;作者本人是一个vim使用者，一直想学函数式的语言于是就挑了Common Lisp，可是问题是CL对vim支持不想Emacs这么好，不过爱折腾的我肯定不会罢休的。&lt;/p&gt;

&lt;p&gt;如果你急着配置你的环境请移步&lt;strong&gt;总结&lt;/strong&gt;&lt;br /&gt;
准备工作
——
1.Python环境（作者使用的是Python 2.7.x的版本）&lt;/p&gt;

&lt;p&gt;2.重新编译的Vim需要支持Python&lt;/p&gt;

&lt;p&gt;3.下载slimv的插件&lt;/p&gt;

&lt;h2 id=&quot;折腾过程&quot;&gt;折腾过程&lt;/h2&gt;

&lt;p&gt;作者在这些准备齐全过后按照&lt;a href=&quot;(http://www.vim.org/scripts/script.php?script_id=2531)&quot;&gt;官网&lt;/a&gt;上面的介绍解压到.vim文件夹之后使用“,c”这个快捷键呼出STREAM结果没有任何反应。然后我就在作者制作的&lt;a href=&quot;(http://kovisoft.bitbucket.org/tutorial.html)&quot;&gt;Slimv Tutorial&lt;/a&gt;第一篇里面看到原来需要一个common Lisp的编译器于是连忙用Home brew下了sbcl&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;brew install sbcl&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装完sbcl之后很明显还是不能用(╯‵□′)╯︵┻━┻于是我就在怀疑是不是我的VIM的配置的问题果然我又在&lt;a href=&quot;(http://kovisoft.bitbucket.org/tutorial.html)&quot;&gt;Tutorial&lt;/a&gt;里面找到了可能需要在.vimrc文件里面添加一段代码&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;On Linux this can be something like:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;let g:slimv_swank_cmd =’! xterm -e sbcl –load /usr/share/common-lisp/source/slime/start-swank.lisp &amp;amp;’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里我只介绍怎么在Mac的环境里面配置所以就不管别的平台下面的配置了所以我在我的.vimrc文件里面添加了作者给的代码&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;let g:slimv_swank_cmd =&apos;! xterm -e sbcl --load /usr/share/common-lisp/source/slime/start-swank.lisp &amp;amp;&apos;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们可以简单的看一下这个代码貌似是用一个终端控制台在后台开启什么东西的样子（其实是在后台开启slime这个我们后面会知道）。于是我填了代码之后还是没有什么用处。好吧，于是我就求助了Baidu和Google这两个大神了，得到的结果很不理想，基本上common Lisp环境配置都是在Emacs上面的只有很少的页面是讲怎么在OSX上面配置VIM+slimv的兜兜转转我在豆瓣的读书笔记里面找到&lt;a href=&quot;(http://book.douban.com/annotation/15415332/)&quot;&gt;这篇&lt;/a&gt;文章，从笔记里面我知道原来不能用terminal里面的vim来使用slimv，其实好像是可以的只要加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set guioptions+=m&lt;/code&gt;来打开菜单就能使用了（我的打不开也不知道为什么有知道的vimer记得告诉我，谢谢）言归正传，知道不能在终端打开vim我只能用Macvim来代替了，果然使用了MacVim之后就可以看到菜单栏里面的slimv的选项菜单了，但是（我已经不想看到这个词了）还是不能用，不过根据上面的笔记来说，我猜我这里出的问题可能是我的MacVim不支持Python于是我准备下一下MacVim的&lt;a href=&quot;(https://code.google.com/p/macvim/wiki/Building)&quot;&gt;源代码&lt;/a&gt;来自己编译&lt;strong&gt;具体编译流程url里面很详细&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;经过一会编译出来符合要求&lt;strong&gt;支持Python和是32位的vim&lt;/strong&gt;的MacVim后再实验还是不可以。
于是我就想会不会是common Lisp的编译器的问题于是我用&lt;strong&gt;Home brew&lt;/strong&gt;下载了ccl&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;brew install Clozure CL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;把在.vimrc里面的脚本改成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;let g:slimv_swank_cmd = &apos;!osascript -e &quot;tell application \&quot;Terminal\&quot; to do script \&quot;ccl --load ~/.vim/slime/start-swank.lisp\&quot;&quot;&apos;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;再运行终于可以了。
~(≧▽≦)/~&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这次对slimv的折腾，几番周折，主要没有中文的资料很麻烦后来在&lt;a href=&quot;(http://book.douban.com/annotation/15415332/)&quot;&gt;douban笔记&lt;/a&gt;里面找到了资料真的需要感谢下这个作者。
我在梳理一下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你需要一个支持Python和32位的MacVim （你可能需要自己编译&lt;a href=&quot;(https://code.google.com/p/macvim/wiki/Building)&quot;&gt;这里&lt;/a&gt;了解细节）&lt;/li&gt;
  &lt;li&gt;你需要一个Python的运行环境&lt;/li&gt;
  &lt;li&gt;你需要下载slimv的插件并且解压到.vim文件夹里&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unzip xxx.zip -d ~/.vim&lt;/code&gt;（&lt;a href=&quot;(http://www.vim.org/scripts/script.php?script_id=2531)&quot;&gt;这里&lt;/a&gt;下载）&lt;/li&gt;
  &lt;li&gt;你需要一个ccl的common Lisp的解释器 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;brew install Clozure CL&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在你的.vimrc文件里面添加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;let g:slimv_swank_cmd = &apos;!osascript -e &quot;tell application \&quot;Terminal\&quot; to do script \&quot;ccl --load ~/.vim/slime/start-swank.lisp\&quot;&quot;&apos;&lt;/code&gt;（这不是必须得）&lt;/li&gt;
  &lt;li&gt;最后打开你的MacVim跟着作者的&lt;a href=&quot;(http://kovisoft.bitbucket.org/tutorial.html)&quot;&gt;tutorial&lt;/a&gt;来学习使用吧&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后，希望我的文章能给爱折腾的你一点用，希望你们能坚持common Lisp的学习，与你共勉&lt;/p&gt;

&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/cn/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; style=&quot;border-width:0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/3.0/cn/80x15.png&quot; /&gt;&lt;/a&gt;&lt;br /&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/cn/&quot;&gt;知识共享署名-非商业性使用-禁止演绎 3.0 中国大陆许可协议&lt;/a&gt;进行许可。
&lt;strong&gt;本文章遵循CC协议，请自觉遵守    -作者Niclas&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2013-12-30 20:00&lt;/p&gt;

</description>
          <pubDate>2014-02-23T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/2014/02/23/vim+slimv%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</link>
          <guid isPermaLink="true">http://localhost:4000/2014/02/23/vim+slimv%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</guid>
        </item>
      
    
      
        <item>
          <title>Mac中安装配置bochs(with SDL)</title>
          <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我为了做一些系统编程需要使用&lt;a href=&quot;www.&quot;&gt;bochs&lt;/a&gt;来做一些调试和模拟的工作,所以需要在自己的Mac上面安装bochs，因为需要debug的功能所以自己需要一个自己编译版本的bochs所以就在SF上面下载了&lt;a href=&quot;www.&quot;&gt;bochs-2.6&lt;/a&gt;来自己编译安装。&lt;/p&gt;

&lt;p&gt;几经波折。还是没有成功安装bochs最后只能求助&lt;a href=&quot;http://stackoverflow.com/questions/1677324/compiling-bochs-on-mac-os-x-snow-leopard/18544680#18544680&quot;&gt;StackOverflow&lt;/a&gt;。下面是我结合在爆栈上面看到的总结的步骤希望能帮到你。&lt;/p&gt;

&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;p&gt;1.下载&lt;a href=&quot;www.&quot;&gt;bochs-2.6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.下载&lt;a href=&quot;http://www.libsdl.org&quot;&gt;Install the SDL 1.2 Library&lt;/a&gt; 或者可以使用&lt;strong&gt;Homebrew&lt;/strong&gt;安装 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;brew install sdl&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;步骤&quot;&gt;步骤&lt;/h2&gt;
&lt;p&gt;修改.conf.macx中的配置如下&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./configure --enable-ne2000 \
        --enable-all-optimizations \
        --enable-cpu-level=6 \
        --enable-x86-64 \
        --enable-vmx=2 \
        --enable-pci \
        --enable-usb \
        --enable-usb-ohci \
        --enable-e1000 \
        --enable-debugger \
        --enable-disasm \
        --disable-debugger-gui \
        --with-sdl \
        --prefix=$HOME/opt/bochs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chmod u+x .conf.macx &amp;amp;&amp;amp; ./.conf.macx&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;直接&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo make &amp;amp;&amp;amp; make install&lt;/code&gt; 就可以了&lt;/p&gt;

&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;这里吐槽一下bochs的团队，因为Apple放弃了Carbon转投Cocoa就不做x64的版本的bochs了，还撂下话说反正bochs是开源软件你能自己添加就自己动手吧（&lt;a href=&quot;http://appleinsider.com/articles/12/02/18/mountain_lion_focuses_on_cocoa_drops_x11_and_deprecates_carbon&quot;&gt;傲娇脸&lt;/a&gt;。
好了，其实最后我还是希望有能力阅读外文的同学去StackOverflow注册一个账号，答答题问问问题比在X度和知乎靠谱多了。&lt;/p&gt;

&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/cn/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; style=&quot;border-width:0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/3.0/cn/80x15.png&quot; /&gt;&lt;/a&gt;&lt;br /&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/cn/&quot;&gt;知识共享署名-非商业性使用-禁止演绎 3.0 中国大陆许可协议&lt;/a&gt;进行许可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文章遵循CC协议，请自觉遵守    -作者Niclas&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2014年2月23日 下午1:10&lt;/p&gt;

</description>
          <pubDate>2014-02-23T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/2014/02/23/Mac%E4%B8%8A%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEbochs.html</link>
          <guid isPermaLink="true">http://localhost:4000/2014/02/23/Mac%E4%B8%8A%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEbochs.html</guid>
        </item>
      
    
      
        <item>
          <title>C中的const测试解析</title>
          <description>&lt;p&gt;===
前言
—&lt;/p&gt;

&lt;p&gt;刚刚我在逛Coolshell的时候看到一个人在评论里面提了一个问题，我修改了一下代码代码如下所示。
开始
–
    #include &lt;stdio.h&gt;
    int main(int argc, char **argv)
    {
      const int a = 10;
	  int *b = &amp;a;
	  //const int *c = &amp;a; /*P指向的数据是常量*/
	  //int const *c = &amp;a; /*P指向的数据是常量*/
      //int * const c = &amp;a;   /*P本身是常量*/&lt;/stdio.h&gt;&lt;/p&gt;

  	  printf(“ a %p:%d  b %p:%d\n”, &amp;amp;a, a, b, *b);
  	  *b = 5;
  	  printf(“ a %p:%d  b %p:%d\n”, &amp;amp;a, a, b, *b);
  	  return 0;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;好了，首先我们先看一下上面的代码，&lt;/p&gt;

&lt;p&gt;第一行定义了一个const修饰的int类型的变量a，然后定义一个指针b并赋值a，随后在打印a，b的地址和变量之后用指针b改变了
a的值，再继续打印b的值。&lt;/p&gt;

&lt;p&gt;然后我们使用gcc编译后加上-wall选项之后只有一句警告：initialization discards qualifiers from pointer target type.也就是被指针指过之后就会降低变量的资格（const的资格）具体是因为什么等我明天再网上查查就能知道。&lt;/p&gt;

&lt;p&gt;但是这里给出解决方案如果你想保护一个变量不被你的指针胡乱修改请再指针上修饰表示自己指向的值不能修改，而不是在值的地方修改。&lt;/p&gt;

&lt;p&gt;另外我实验了三种添加const的位置 首先const是一个左结合修饰符也就是标准写法应该像我注释的倒数两行一样书写。
第一种是不同的具体因为什么原因等我去找一找。&lt;/p&gt;

&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/cn/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; style=&quot;border-width:0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/3.0/cn/80x15.png&quot; /&gt;&lt;/a&gt;&lt;br /&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/cn/&quot;&gt;知识共享署名-非商业性使用-禁止演绎 3.0 中国大陆许可协议&lt;/a&gt;进行许可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文章遵循CC协议，请自觉遵守    -作者Niclas&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2014年2月23日 下午11:18&lt;/p&gt;

</description>
          <pubDate>2014-02-23T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/2014/02/23/C%E4%B8%AD%E7%9A%84const.html</link>
          <guid isPermaLink="true">http://localhost:4000/2014/02/23/C%E4%B8%AD%E7%9A%84const.html</guid>
        </item>
      
    
      
        <item>
          <title>Lose one‘s force</title>
          <description>&lt;p&gt;刚刚在LOFTER上面看到了 一个文章，它里面只有一张照片和一首诗。黑白照片上面只有一个手臂手臂上面贴着超市的价格标签。诗是这么写的
Price Tag
Seems like everybody’s got a price,
I wonder how they sleep at night
When the sale comes first
And the truth comes second.
Just stop for a minute and smile&lt;/p&gt;

&lt;p&gt;Why is everybody so serious?
Acting so damn mysterious?
Got your shades on your eyes
And your heels so high
That you can’t even have a good time&lt;/p&gt;

&lt;p&gt;Everybody look to their left 
Everybody look to their right
Can you feel that 
We’re paying with love tonight?&lt;/p&gt;

&lt;p&gt;It’s not about the money, money, money
We don’t need your money, money, money
We just wanna make the world dance,
Forget about the price tag
Ain’t about the cha-ching cha-ching
Ain’t about the ba-bling ba-bling
Wanna make the world dance,
Forget about the price tag OK?”
诗中作者一直在强调或者呼吁人们不要过度在意标签（价值）或者说不要太在意钱 “It’s not about the money, money money, money”诚然，现在的社会对钱的重视程度一直都是最大的，导致很多人忘记了初心（losethem force）忘记了一开始的自己只是想跳舞而已的，我也不知道为什么我的LOFTER里面很多文章都是在告诫自己不要忘记初心的文章，也许我就是通过这种方式来提醒自己不要做这些事情吧。
也许钱的确是很有使用价值的替代品，可是往往这种“万能”的替代品不能代替的总是一些无形的物品。
物质上的需求本身就是不能满足精神上得需求的，你永远不能用美食喂饱一个需要获取知识的人。物质只是底层需求，可能在我们能够分配底层需求的时候我才会对精神需求有足够的重视，换句话说其实精神需求应该如何划分都不好说，如果按是否能被金钱满足来划分其实绝大多数精神需求都是需要被金钱满足的（哦，经济是基础）。所以我们不能用“不能被金钱所购买来区分精神需求和物质需求”
所以呢，我不太理解。希望以后的我能给我解答。
2014 01 01  ——–Nicalis @Nanjing&lt;/p&gt;

</description>
          <pubDate>2014-01-01T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/essay/2014/01/01/Lose-one-s-force.html</link>
          <guid isPermaLink="true">http://localhost:4000/essay/2014/01/01/Lose-one-s-force.html</guid>
        </item>
      
    
      
        <item>
          <title>My frist Document nightly</title>
          <description>&lt;p&gt;这是我第一次在这个软件里面写字，我也是第一次能如此震撼的写下文字，
这里的一切都显得这么和谐音乐，简约的风格，流畅的输入的感觉一切的一切都
显得这么自然。 ——————————————Niclas
也许像这软件的介绍一样，他能给我带来不一样的输入体验，一种全新的体验，我能在这里享受书写对我的刺激，加速进入心流的速度，减少时间，我知道这个软件对于english 的字体体验很是丰富，我会尽量使用英文来书写这里的文字，也许是因为太累的原因吧，我有点困了，今天就先到这里，我明天就下单入手这个App希望这个公司能够继续蓬勃发展，我也能慢慢沉淀，沉淀到我这桶水不至于这么黑。这么说我就明天在这里总结下我这一年的大大小小的事情吧，晚安。&lt;/p&gt;

</description>
          <pubDate>2013-12-28T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/essay/2013/12/28/My-frist-Document.html</link>
          <guid isPermaLink="true">http://localhost:4000/essay/2013/12/28/My-frist-Document.html</guid>
        </item>
      
    
      
        <item>
          <title>2013 忆</title>
          <description>&lt;p&gt;对我来说2013算是一个转折点得一年了吧。大大小小的事情都是发生在这一年的，就跟我自己做着回忆的火车伴奏轰隆轰隆的杂鸣踏上我的回忆之路吧。———————Niclas
春：
我记得2013年的除夕是在2月的时候，1月的我好像刚刚才从失恋的事件里慢慢走出来，这件事情又要往回退3个月。2012年的11月1号（我本来忘记了这个日子后来因为Efan的提醒我又特地回去看了一下）跟我相恋的女友要跟我分手了，那时候很伤心，现在想想这未尝不是一种人生的体验呢（说这样的话真的是就是安慰自己吧）我没有告诉身边的朋友也尽量不要让自己的负能量传播出去，只是没有这么活泼换个接地气的词没有这么2了吧。就这样慢慢的调整自己的心情，收拾心情找一个没有认识的人的地方宣泄，于是我去了LOFTER，去了PaPa，我然我在那里遇到了很多朋友，他们热情阳光，这也改变了我对“网友”这个词的最初的印象，我是一个传统中国教育教育出来的小孩，也就是每天被教导的就是不要给别人添麻烦也不要给自己添麻烦是一种“自扫门前雪，勿扫别人挖上霜”的处事哲学（我本身不喜欢这样的方法），所以网络的朋友给我的理解就是“陌生人”对于陌生人的处理方式就是漠视无视。不过在我在这两个轻社区平台上面的经历让我知道，这世界上有这么一群人，他们不是这样的（不是像我一样），他们乐于认识交流乐于和陌生人交换经历，喜欢帮助别人，我想也就是因为这样，她们满满的热情才把我携带的负能量统统驱赶走。
说完了感情上得事情，其实2013年春天的时候是我学历上面的转折点，我成功的通过了升学测试考回了家。也许在我的同学眼里我就是一个什么都不用学但是每次考试都是考的很好的怪咖，也许在他们眼里我还是一个奇怪的人，从来看不到我洗漱睡觉，可是又每天早上看到我在床上睡觉。这点我想对我前面的舍友说声抱歉，其实最多的是想说声谢谢，说抱歉就是也许我对你们的处事的方法不对，有的时候没有顾及到你们的自尊心，说谢谢的原因是谢谢你们的宽容，谢谢你们能容忍我的怪习惯小心眼。我知道226已经没有人住了，我希望你们在学校的在工作岗位的好好的以后希望还能聚在一起。我知道我们宿舍其实是这么多宿舍里面最努力的，也许你们到大一才摸过电脑但是你们现在不是各个都可以使用SSH框架，Mysql数据库这些有些计算机牛人都不一定会得东西吗，总之，珍重，我走了，我会回来的。
夏：
关于夏天的回忆我都有些不记得了，有人说，记忆的缺失有一大部分原因是因为有不好的回忆。
秋：
冬：
说实话，比起夏天我更喜欢冬天，可能是缺乏安全感的关系吧，我喜欢被被子包围的感觉。
冬天，我接受了Chelsea的建议，不谈恋爱。我现在想想其实我应该付出更多才是。不应该然女生付出。
其实我现在想想终于知道为什么有的人找对象需要条条框框，可能是因为以前的失败经历吧，想我现在就想找一个不算丑也不算漂亮的姑娘，也不一定需要会什么但是一定要善良，我们谈恋爱一定是家里人赞同的不能是异地恋，至少两个人要能常常见面的这种距离就可以了。可能我再有这么几次失败的经历也许就会有更多的要求吧。&lt;/p&gt;

&lt;p&gt;总：
纵观我对2013的看法，还是情感上面的问题比较多，也不知道是因为就是这样还是最近我对这方面的感触多的原因呢，
结束吧，还有3天就跨年了，希望我能在2014年有新的感触，希望能看到2年约定的结果。我需要沉淀，无论从技术还是思想，都需要沉淀。&lt;/p&gt;

</description>
          <pubDate>2013-12-28T00:00:00+08:00</pubDate>
          <link>http://localhost:4000/essay/2013/12/28/2013MM.html</link>
          <guid isPermaLink="true">http://localhost:4000/essay/2013/12/28/2013MM.html</guid>
        </item>
      
    
  </channel>
</rss>
