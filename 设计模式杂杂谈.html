<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1" />


	<title>设计模式杂杂谈 · 朝四暮三</title>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
          delimiters: [
              {left: "$$", right: "$$", display: true},
              {left: "$", right: "$", display: false}
          ]
      });
  });
</script>

<script type="module">
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
mermaid.initialize({ startOnLoad: true });
</script>

<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@" />
<meta name="twitter:title" content="设计模式杂杂谈" />
<meta name="twitter:description" content="  北冥有鱼，其名为鲲。鲲之大，不知其几千里也。化而为鸟，其名 为鹏。鹏之背，不知其几千里也。怒而飞，其翼若垂天之云。是鸟也 ，海运则将徙于南冥。南冥者，天池也。 – 庄子">

<meta name="description" content="  北冥有鱼，其名为鲲。鲲之大，不知其几千里也。化而为鸟，其名 为鹏。鹏之背，不知其几千里也。怒而飞，其翼若垂天之云。是鸟也 ，海运则将徙于南冥。南冥者，天池也。 – 庄子">



<link rel="icon" href="https://niclas3.github.io/assets/favicon.png">
<link rel="apple-touch-icon" href="https://niclas3.github.io/assets/touch-icon.png">
<link rel="stylesheet" href="https://niclas3.github.io/assets/core.css">
<link rel="canonical" href="https://niclas3.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%82%E6%9D%82%E8%B0%88">
<link rel="alternate" type="application/atom+xml" title="朝四暮三" href="https://niclas3.github.io/feed.xml" />



	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga( 'create', '', 'auto' );
		ga( 'send', 'pageview' );
	</script>







	</head>

	<body>
                <a href="/about">About</a>
		<aside class="logo">

	

	<a href="/">
            <img src="/assets/headImg.png" class="gravatar">
	</a>
	<span class="logo-prompt">Back to Home</span>

</aside>


		<main>
			<article>

	<div class="center">
		<h1>设计模式杂杂谈</h1>
		<time>May 26, 2016</time>
	</div>

	<div class="divider"></div>

	<blockquote>
  <p>北冥有鱼，其名为鲲。
鲲之大，不知其几千里也。
化而为鸟，其名 为鹏。鹏之背，不知其几千里也。
怒而飞，其翼若垂天之云。是鸟也 ，海运则将徙于南冥。
南冥者，天池也。 – 庄子</p>
</blockquote>

<p>不知道从什么时候起设计模式，慢慢变成一个装逼必备的理论开始被讨论了，也许50年了。今天我们聊一种模式
##Strategy Pattern
我们先不说这些有的没的模式该是什么表现形式，照例应该先吹比。首先说说Strategy pattern的strategy是什么意思</p>
<blockquote>
  <p>a plan of action or policy designed to achieve a major or overall aim.
（以上是Google translate友情提供翻译。）</p>
</blockquote>

<p>说Strategy是为了一个长期的目标制定的一个动作。从这种解释可以看出来，这个模式其实是代码中的动作（函数，方法）的集合。我想大家看过三国吧，Strategy pattern就像诸葛老儿给的锦囊计，你要用的时候找我,我给你我的技巧。（这里要注意的是，1.这个给的只是方法而不是对象（我说的这个对象是，即封装了属性又封装了方法的对象）。他在代码的表现形式上更像一个属性，你通过setter和getter方法改变和获取这个可设置的Strategy。</p>

<ol>
  <li>设计模式整体的概念在于抽象世界，所以他们常常把在<strong>不同情况</strong>下改变的东西变得可以改变并且<strong>提出来</strong>。</li>
  <li>设计模式里面还有一个技巧，通过在类里实现一个空方法，调用组合对象的方法来提高并封装了组合对象的方法调用层级。让使用者认为自己在调用产生类的方法，而其实是产生类中组合实例的函数。</li>
</ol>

<p>##🌰我来举个老师去上课的例子吧</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import Foundation
/// 这是锦囊类
protocol TeachCategorical {
    func teach()
}

class MathClass: TeachCategorical {
    func teach() {
        print("教数学")
    }
}

class EnglishClass: TeachCategorical {
    func teach() {
        print("教语文")
    }
}
/// ------------我是分割线 -----------
class ClassRoom  {
    private var teachFunction: TeachCategorical! = MathClass()
    
    func setTeachFunction(teach: TeachCategorical) {
        self.teachFunction = teach
    }
    
    func publish() {
        self.teachFunction.teach()
    }
}

class MathClassRoom: ClassRoom {
    override init() {
        super.init()
    }
    
    func teachMath() {
        self.setTeachFunction(MathClass())
    }
}

class EnglishClassRoom: ClassRoom {
    override init() {
        super.init()
    }
    
    func teachEnglish() {
        self.setTeachFunction(EnglishClass())
    }
}


let mathroom : MathClassRoom = MathClassRoom()
mathroom.teachMath()
mathroom.publish()

let englishRoom :EnglishClassRoom = EnglishClassRoom()
englishRoom.teachEnglish()
englishRoom.publish()
 
</code></pre></div></div>
<p>我把Strategy封装成接口（ps把需要抽象的方法做成接口，是个非常明智的选择，这恰恰也是接口存在的意义）然后写了两个不同的锦囊类。分别实现了teach方法用来教课。</p>

<p>下面就是需要把不同的教室分配为不同的职能了。于是，应该发生的样子应该是数学教师用来教数学，英文教室教英文。</p>

<p>把教室抽象出来并且给教室一个『锦囊』属性让教室在想设置这个教室职能的时候可以设置。（当然这种设置可以放在任何初始化内部对象的地方比如init方法，set方法之类的）。
教室还有一个职能就是让这个『锦囊』有用（也就是调用这个实例的方法）</p>

<p>这里很好的看到了，我把整个程序分割成两个部分。</p>
<ol>
  <li>锦囊</li>
  <li>手持锦囊的一群东西</li>
</ol>

<p>这就是Strategy模式。
记住的是，你在编码的时候发现什么被经常改动。如果改动的是方法，记得使用接口封装他们。如果改动的是数据结构，我们下次再说用什么。</p>

<hr />
<p>##同胞兄弟 Factory Pattern</p>
<h3 id="defalut-factory-pattern">defalut factory pattern</h3>
<p>为什么要在一起说这两个pattern呢，因为我觉得从结构上来看他们很像，可以一起<strong>横向对比</strong>。
照例我们还是先从名字入手，factory，没啥好介绍的。名词:工厂。也就是说，我们可以通过这个『工厂』来『制造』并且产出『产品』，这里的『产品』就是我们想要批量生产或者方便添加的类。
有上述可以得到，我们在这个模式中需要定义产品对象。自然而然的，我们需要定义接口来指导行为。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 简单工厂模式样例
/* ------- */
/// 这是产品类
protocol Operators {
    func perform()
}

class Addition: Operators {
    func perform() {
        print("做加法")
    }
}

class Minies: Operators {
    func perform() {
        print("做减法")
    }
}

class Divice: Operators {
    func perform() {
        print("做除法")
    }
}

class Mutiple: Operators {
    func perform() {
        print("做乘法")
    }
}

enum operatorsEnum {
    case Add, Minie, Divice, Mutiple
}
</code></pre></div></div>
<p>由此可见，这个产品的模板其实和策略模式的策略类的表现形式如出一辙。继续看工厂类的实现</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class OperatorsFactory {
    func createOperatorWithType(operat: operatorsEnum) -&gt; Operators {
        var operators : Operators
        switch operat{
        case .Add :
            operators = Addition()
        case .Divice:
            operators = Divice()
        case .Minie:
            operators = Minies()
        case .Mutiple:
            operators = Mutiple()
        }
        return operators
    }
}
</code></pre></div></div>
<p>作为简单工厂，只需要一个函数来产生不同的产品，通过接口来使用『里氏替换原则』接受所有的产品类型，返回产品实例。
最后看一下使用方法。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class User {
    var factory: OperatorsFactory
    init(operaFactory: OperatorsFactory) {
        self.factory = operaFactory
    }
    
    func perfromWithType(opType: operatorsEnum) {
        let weapon: Operators = factory.createOperatorWithType(opType)
        weapon.perform()
    }
}

let users = User(operaFactory: OperatorsFactory())
users.perfromWithType(.Add)
users.perfromWithType(.Minie)
</code></pre></div></div>
<p>首先使用者类中，存在一个组合的工厂类的实例（这样一点又和策略模式的角色类的实现相同），然后有一个方法（createOperatorWithType :opType）通过外部的产品类型返回实例，直接调用这个实例的方法（以转换为用户类的方法）</p>
<h3 id="factory-method-pattern">Factory Method Pattern</h3>
<blockquote>
  <p><strong>变量就是类，类和变量的相互转化</strong></p>
</blockquote>

<p>老生常谈了，我们还是从名字开始入手，『工厂方法』这名字可能说明不了什么问题（比较像中国人起的名字）</p>

<blockquote>
  <p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫<strong>虚拟构造器</strong>(Virtual Constructor)模式或者<strong>多态工厂</strong>(Polymorphic Factory)模式，</p>
</blockquote>

<p>Virtual Constructor Pattern和Polymorphic Factory Pattern这两个名字就很能说明问题了。
在计算机科学里面常常有人喜欢说Virtual这个词，『虚拟化』听上去就很牛逼，基本上看到这个词的时候就知道这个人是把什么东西抽象成一个抽象描述了，而在代码实现中接口就是这种抽象描述。再看看Polymorphic Factory就能知道这个『工厂』可能是很多的。（一般这种很多的东西，就是通过不同的类来分割职能，所以需要使用接口把他们统一起来）</p>

<p>来我们使用Virtual constructor 重构上面的简单工厂看看。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class OperationDecorator: Operators {
    var operat: Operators! = nil
    init(opera: Operators) {
        self.operat = opera
    }
    func perform() -&gt; String{
        return operat.perform()
    }
}

class DoubleDecorator: OperationDecorator {
    override func perform() -&gt; String{
        return "浮点数" + self.operat.perform()
    }
}

class IntDecorator: OperationDecorator {
    override func perform() -&gt; String {
        return "整数" + self.operat.perform()
    }
}

</code></pre></div></div>
<p>这里写了两个产品，</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol OperationUser {
    func performfWithType(operationType: operatorsEnum)
    func createOperaWithType(operationType: operatorsEnum) -&gt; Operators!
}

extension OperationUser {
    func performfWithType(operationType: operatorsEnum) {
        let opt: Operators! = createOperaWithType(operationType)
        print(opt.perform())
    }
}

class DoubleUser: OperationUser {
    func createOperaWithType(operationType: operatorsEnum) -&gt; Operators! {
        var opt: Operators
        switch operationType {
        case .Add:
            opt = DoubleDecorator(opera: Addition())
        case .Divice:
            opt = DoubleDecorator(opera:  Divice())
        case .Minie:
            opt = DoubleDecorator(opera:  Minies())
        case .Mutiple:
            opt = DoubleDecorator(opera:  Mutiple())
        }
        return opt
    }
}

var user: OperationUser = DoubleUser()

user.performfWithType(.Add)
</code></pre></div></div>
<p>###Abstract Factory Pattern
抽象工厂模式的主要作用就是把上述的工厂类的方法抽象成接口。我们直接看代码。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol WeaponType {
    func fire() -&gt; String
}

class AK: WeaponType {
    func fire() -&gt; String {
        return "AK: Fire"
    }
}

class AWP: WeaponType {
    func fire() -&gt; String {
        return "AWP: Fire"
    }
}

class HK: WeaponType {
    func fire() -&gt; String {
        return "HK: Fire"
    }
}

class WeaponDecorator: WeaponType {
    var weapon: WeaponType! = nil
    init(weapon: WeaponType) {
        self.weapon = weapon
    }
    
    func fire() -&gt; String {
        return weapon.fire()
    }
}

class GermanyDecorator: WeaponDecorator {
    override func fire() -&gt; String {
        return "德国制造" + self.weapon.fire()
    }
}


class AmericaDecorator: WeaponDecorator {
    override func fire() -&gt; String {
        return "美国制造" + self.weapon.fire()
    }
}

/**
 *  抽象工厂接口
 */
protocol WeaponFactoryType {
    func createAK() -&gt; WeaponType
    func createAWP() -&gt; WeaponType
    func createHK() -&gt; WeaponType
}

/// 抽象工厂的具体类实现

class AmericanWeaponFactory: WeaponFactoryType {
    func createAK() -&gt; WeaponType {
        return AmericaDecorator(weapon: AK())
    }
    
    func createHK() -&gt; WeaponType {
        return AmericaDecorator(weapon: HK())
    }
    
    func createAWP() -&gt; WeaponType {
        return AmericaDecorator(weapon: AWP())
    }
}

class GermanyWeaponFactory: WeaponFactoryType {
    func createAWP() -&gt; WeaponType {
        return GermanyDecorator(weapon: AWP())
    }
    
    func createHK() -&gt; WeaponType {
        return GermanyDecorator(weapon: HK())
    }
    
    func createAK() -&gt; WeaponType {
        return GermanyDecorator(weapon: AK())
    }
}

enum WeaponTypeEnumeration {
    case AK, AWP, HK
}

class WeaponUser {
    private var factory: WeaponFactoryType
    init(factory: WeaponFactoryType) {
        self.factory = factory
    }
    
    func setFactory(factory: WeaponFactoryType) {
        self.factory = factory
    }
    
    func fireWithType(weaponType: WeaponTypeEnumeration) {
        var weapon: WeaponType
        switch weaponType {
        case .AK:
            weapon = self.factory.createAK()
        case .AWP:
            weapon = self.factory.createAWP()
        case .HK:
            weapon = self.factory.createHK()
        }
        
        print(weapon.fire())
    }
}


var user: WeaponUser = WeaponUser(factory: AmericanWeaponFactory())

user.fireWithType(.AWP)
user.fireWithType(.HK)

user.setFactory(GermanyWeaponFactory())
print("\n")
user.fireWithType(.AWP)
user.fireWithType(.HK)

</code></pre></div></div>
<p>上述代码和工厂方法模式对于user的封装基本相同，都是组合一个工厂，只是这次的是一个抽象的接口，上次是类。</p>
<h3 id="工厂方法和抽象工厂模式的异同">工厂方法和抽象工厂模式的异同</h3>
<p>其实抽象工厂是通过接口来产生工厂的集合，而工厂方法会选取工厂来『生产』</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 *  对使用者抽象
 */
protocol WeaponUserType {
    func fireWithType(weaponType: WeaponTypeEnumeration)
    func createWeaponWithType(weaponType: WeaponTypeEnumeration) -&gt; WeaponType!
    func createWeaponFactory() -&gt; WeaponFactoryType
}

extension WeaponUserType {
    func fireWithType(weaponType: WeaponTypeEnumeration) {
        let weapon: WeaponType = createWeaponWithType(weaponType)
        print(weapon.fire())
    }
    
    func createWeaponWithType(weaponType: WeaponTypeEnumeration) -&gt; WeaponType! {
        var weapon: WeaponType
        
        switch weaponType {
        case .AK:
            weapon = createWeaponFactory().createAK()
        case .AWP:
            weapon = createWeaponFactory().createAWP()
        case .HK:
            weapon = createWeaponFactory().createHK()
        }
        
        return weapon
    }
}

class AmericanWeaponUser: WeaponUserType {
    func createWeaponFactory() -&gt; WeaponFactoryType {
        return AmericanWeaponFactory()
    }
}

class GermanyWeaponUser: WeaponUserType {
    func createWeaponFactory() -&gt; WeaponFactoryType {
        return GermanyWeaponFactory()
    }
}

var usr: WeaponUserType = AmericanWeaponUser()
usr.fireWithType(.AK)
</code></pre></div></div>
<p>在这里工厂方法模式的具体实现就是User接口实现类的<code class="language-plaintext highlighter-rouge">func createWeaponFactory() -&gt; WeaponFactoryType</code>方法。通过不同类对于这个方法的实现，实现工厂的选取，选取工厂是在<code class="language-plaintext highlighter-rouge">var usr: WeaponUserType = AmericanWeaponUser()</code>产生的。</p>

<p>参考链接
<a href="http://so.gushiwen.org/guwen/bookv_3254.aspx">逍遥游</a>
<a href="http://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/strategy.html">策略模式</a>
<a href="http://www.cnblogs.com/ludashi/p/5302269.html">参考博客Swift实现</a></p>



</article>

<div class="page-navigation">
	
    <a class="next" href="https://niclas3.github.io/podcast/onlybook/%E4%B8%89%E4%BA%BF%E5%B7%A8%E5%A5%96%E4%BB%8E%E5%A4%A9%E8%80%8C%E9%99%8D-%E4%BD%A0%E7%9A%84%E4%BA%BA%E7%94%9F%E4%BC%9A%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E" title="NEXT: 三亿巨奖从天而降，你的人生会何去何从">&lt;&lt;</a>
		<span> &middot; </span>
  
		<a class="home" href="https://niclas3.github.io" title="Back to Homepage">Home</a>
  
		<span> &middot; </span>
    <a class="prev" href="https://niclas3.github.io/share/podcast/onlybook/Rework-%E9%87%8D%E6%9D%A5" title="PREV: Rework · 重来">&gt;&gt;</a>
  
</div>

		</main>

		<div class="footer">
  <span class="block">😝 <a href="/" title="">曰 朝三而暮四 众狙皆怒 然则朝四而暮三 众狙皆悦</a> by <a href="http://niclas3.github.io">M</a>.</span>
  <span class="block">&copy; 2025 niclas</span>
</div>


	</body>

</html>
